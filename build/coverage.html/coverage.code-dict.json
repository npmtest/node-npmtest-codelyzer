{"/home/travis/build/npmtest/node-npmtest-codelyzer/test.js":"/* istanbul instrument in package npmtest_codelyzer */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-codelyzer/lib.npmtest_codelyzer.js":"/* istanbul instrument in package npmtest_codelyzer */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_codelyzer = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_codelyzer = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-codelyzer/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-codelyzer && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_codelyzer */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_codelyzer\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_codelyzer.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_codelyzer.rollup.js'] =\n            local.assetsDict['/assets.npmtest_codelyzer.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_codelyzer.__dirname + '/lib.npmtest_codelyzer.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/index.js":"\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nvar componentClassSuffixRule_1 = require(\"./componentClassSuffixRule\");\nexports.ComponentClassSuffixRule = componentClassSuffixRule_1.Rule;\nvar componentSelectorRule_1 = require(\"./componentSelectorRule\");\nexports.ComponentSelectorRule = componentSelectorRule_1.Rule;\nvar directiveClassSuffixRule_1 = require(\"./directiveClassSuffixRule\");\nexports.DirectiveClassSuffixRule = directiveClassSuffixRule_1.Rule;\nvar directiveSelectorRule_1 = require(\"./directiveSelectorRule\");\nexports.DirectiveSelectorRule = directiveSelectorRule_1.Rule;\nvar importDestructuringSpacingRule_1 = require(\"./importDestructuringSpacingRule\");\nexports.ImportDestructuringSpacingRule = importDestructuringSpacingRule_1.Rule;\nvar invokeInjectableRule_1 = require(\"./invokeInjectableRule\");\nexports.InvokeInjectableRule = invokeInjectableRule_1.Rule;\nvar noAccessMissingMemberRule_1 = require(\"./noAccessMissingMemberRule\");\nexports.NoAccessMissingMemberRule = noAccessMissingMemberRule_1.Rule;\nvar noAttributeParameterDecoratorRule_1 = require(\"./noAttributeParameterDecoratorRule\");\nexports.NoAttributeParameterDecoratorRule = noAttributeParameterDecoratorRule_1.Rule;\nvar noForwardRefRule_1 = require(\"./noForwardRefRule\");\nexports.NoForwardRefRule = noForwardRefRule_1.Rule;\nvar noInputRenameRule_1 = require(\"./noInputRenameRule\");\nexports.NoInputRenameRule = noInputRenameRule_1.Rule;\nvar noOutputRenameRule_1 = require(\"./noOutputRenameRule\");\nexports.NoOutputRenameRule = noOutputRenameRule_1.Rule;\nvar noUnusedCssRule_1 = require(\"./noUnusedCssRule\");\nexports.NoUnusedCssRule = noUnusedCssRule_1.Rule;\nvar pipeImpureRule_1 = require(\"./pipeImpureRule\");\nexports.PipeImpureRule = pipeImpureRule_1.Rule;\nvar pipeNamingRule_1 = require(\"./pipeNamingRule\");\nexports.PipeNamingRule = pipeNamingRule_1.Rule;\nvar templatesUsePublicRule_1 = require(\"./templatesUsePublicRule\");\nexports.TemplatesUsePublicRule = templatesUsePublicRule_1.Rule;\nvar useHostPropertyDecoratorRule_1 = require(\"./useHostPropertyDecoratorRule\");\nexports.UseHostPropertyDecoratorRule = useHostPropertyDecoratorRule_1.Rule;\nvar useInputPropertyDecoratorRule_1 = require(\"./useInputPropertyDecoratorRule\");\nexports.UseInputPropertyDecoratorRule = useInputPropertyDecoratorRule_1.Rule;\nvar useLifeCycleInterfaceRule_1 = require(\"./useLifeCycleInterfaceRule\");\nexports.UseLifeCycleInterfaceRule = useLifeCycleInterfaceRule_1.Rule;\nvar useOutputPropertyDecoratorRule_1 = require(\"./useOutputPropertyDecoratorRule\");\nexports.UseOutputPropertyDecoratorRule = useOutputPropertyDecoratorRule_1.Rule;\nvar usePipeTransformInterfaceRule_1 = require(\"./usePipeTransformInterfaceRule\");\nexports.UsePipeTransformInterfaceRule = usePipeTransformInterfaceRule_1.Rule;\nvar templateToNgTemplateRule_1 = require(\"./templateToNgTemplateRule\");\nexports.TemplateToNgTemplateRule = templateToNgTemplateRule_1.Rule;\n__export(require(\"./angular/config\"));\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/componentClassSuffixRule.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Lint = require(\"tslint\");\nvar sprintf_js_1 = require(\"sprintf-js\");\nvar walkerFactory_1 = require(\"./walkerFactory/walkerFactory\");\nvar walkerFn_1 = require(\"./walkerFactory/walkerFn\");\nvar function_1 = require(\"./util/function\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super.apply(this, arguments) || this;\n    }\n    Rule.validate = function (className, suffixList) {\n        return suffixList.some(function (suffix) { return className.endsWith(suffix); });\n    };\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(Rule.walkerBuilder(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nRule.metadata = {\n    ruleName: 'component-class-suffix',\n    type: 'style',\n    description: \"Classes decorated with @Component must have suffix \\\"Component\\\" (or custom) in their name.\",\n    descriptionDetails: \"See more at https://angular.io/styleguide#!#02-03.\",\n    rationale: \"Consistent conventions make it easy to quickly identify and reference assets of different types.\",\n    options: {\n        type: 'array',\n        items: {\n            type: 'string',\n        }\n    },\n    optionExamples: [\n        \"true\",\n        \"[true, \\\"Component\\\", \\\"View\\\"]\"\n    ],\n    optionsDescription: \"Supply a list of allowed component suffixes. Defaults to \\\"Component\\\".\",\n    typescriptOnly: true,\n};\nRule.FAILURE = 'The name of the class %s should end with the suffix %s (https://goo.gl/5X1TE7)';\nRule.walkerBuilder = walkerFn_1.all(walkerFn_1.validateComponent(function (meta, suffixList) {\n    return function_1.Maybe.lift(meta.controller)\n        .fmap(function (controller) { return controller.name; })\n        .fmap(function (name) {\n        var className = name.text;\n        var _suffixList = suffixList.length > 0 ? suffixList : ['Component'];\n        if (!Rule.validate(className, _suffixList)) {\n            return [new walkerFactory_1.Failure(name, sprintf_js_1.sprintf(Rule.FAILURE, className, _suffixList))];\n        }\n    });\n}));\nexports.Rule = Rule;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/walkerFactory/walkerFactory.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ng2Walker_1 = require(\"../angular/ng2Walker\");\nfunction allNg2Component() {\n    return new Ng2ComponentWalkerBuilder();\n}\nexports.allNg2Component = allNg2Component;\nvar Failure = (function () {\n    function Failure(node, message) {\n        this.node = node;\n        this.message = message;\n    }\n    return Failure;\n}());\nexports.Failure = Failure;\nvar Ng2ComponentWalkerBuilder = (function () {\n    function Ng2ComponentWalkerBuilder() {\n    }\n    Ng2ComponentWalkerBuilder.prototype.where = function (validate) {\n        this._where = validate;\n        return this;\n    };\n    Ng2ComponentWalkerBuilder.prototype.build = function (sourceFile, options) {\n        var self = this;\n        var e = (function (_super) {\n            __extends(class_1, _super);\n            function class_1() {\n                return _super.apply(this, arguments) || this;\n            }\n            class_1.prototype.visitNg2Component = function (meta) {\n                var _this = this;\n                self._where(meta).fmap(function (failure) {\n                    _this.addFailure(_this.createFailure(failure.node.getStart(), failure.node.getWidth(), failure.message));\n                });\n                _super.prototype.visitNg2Component.call(this, meta);\n            };\n            return class_1;\n        }(ng2Walker_1.Ng2Walker));\n        return new e(sourceFile, options);\n    };\n    return Ng2ComponentWalkerBuilder;\n}());\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/angular/ng2Walker.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Lint = require(\"tslint\");\nvar ts = require(\"typescript\");\nvar compiler = require(\"@angular/compiler\");\nvar templateParser_1 = require(\"./templates/templateParser\");\nvar parseCss_1 = require(\"./styles/parseCss\");\nvar basicCssAstVisitor_1 = require(\"./styles/basicCssAstVisitor\");\nvar basicTemplateAstVisitor_1 = require(\"./templates/basicTemplateAstVisitor\");\nvar recursiveAngularExpressionVisitor_1 = require(\"./templates/recursiveAngularExpressionVisitor\");\nvar referenceCollectorVisitor_1 = require(\"./templates/referenceCollectorVisitor\");\nvar metadata_1 = require(\"./metadata\");\nvar ng2WalkerFactoryUtils_1 = require(\"./ng2WalkerFactoryUtils\");\nvar config_1 = require(\"./config\");\nvar logger_1 = require(\"../util/logger\");\nvar utils_1 = require(\"../util/utils\");\nvar getDecoratorStringArgs = function (decorator) {\n    var baseExpr = decorator.expression || {};\n    var args = baseExpr.arguments || [];\n    return args.map(function (a) { return (a.kind === ts.SyntaxKind.StringLiteral) ? a.text : null; });\n};\nvar Ng2Walker = (function (_super) {\n    __extends(Ng2Walker, _super);\n    function Ng2Walker(sourceFile, _originalOptions, _config, _metadataReader) {\n        var _this = _super.call(this, sourceFile, _originalOptions) || this;\n        _this._originalOptions = _originalOptions;\n        _this._config = _config;\n        _this._metadataReader = _metadataReader;\n        _this._metadataReader = _this._metadataReader || ng2WalkerFactoryUtils_1.ng2WalkerFactoryUtils.defaultMetadataReader();\n        _this._config = Object.assign({\n            templateVisitorCtrl: basicTemplateAstVisitor_1.BasicTemplateAstVisitor,\n            expressionVisitorCtrl: recursiveAngularExpressionVisitor_1.RecursiveAngularExpressionVisitor,\n            cssVisitorCtrl: basicCssAstVisitor_1.BasicCssAstVisitor\n        }, _this._config || {});\n        _this._config = Object.assign({\n            templateVisitorCtrl: basicTemplateAstVisitor_1.BasicTemplateAstVisitor,\n            expressionVisitorCtrl: recursiveAngularExpressionVisitor_1.RecursiveAngularExpressionVisitor,\n            cssVisitorCtrl: basicCssAstVisitor_1.BasicCssAstVisitor\n        }, _this._config || {});\n        return _this;\n    }\n    Ng2Walker.prototype.visitClassDeclaration = function (declaration) {\n        var metadata = this._metadataReader.read(declaration);\n        if (metadata instanceof metadata_1.ComponentMetadata) {\n            this.visitNg2Component(metadata);\n        }\n        else if (metadata instanceof metadata_1.DirectiveMetadata) {\n            this.visitNg2Directive(metadata);\n        }\n        (declaration.decorators || []).forEach(this.visitClassDecorator.bind(this));\n        _super.prototype.visitClassDeclaration.call(this, declaration);\n    };\n    Ng2Walker.prototype.visitMethodDeclaration = function (method) {\n        (method.decorators || []).forEach(this.visitMethodDecorator.bind(this));\n        _super.prototype.visitMethodDeclaration.call(this, method);\n    };\n    Ng2Walker.prototype.visitPropertyDeclaration = function (prop) {\n        (prop.decorators || []).forEach(this.visitPropertyDecorator.bind(this));\n        _super.prototype.visitPropertyDeclaration.call(this, prop);\n    };\n    Ng2Walker.prototype.visitMethodDecorator = function (decorator) {\n        var name = utils_1.getDecoratorName(decorator);\n        if (name === 'HostListener') {\n            this.visitNg2HostListener(decorator.parent, decorator, getDecoratorStringArgs(decorator));\n        }\n    };\n    Ng2Walker.prototype.visitPropertyDecorator = function (decorator) {\n        var name = utils_1.getDecoratorName(decorator);\n        switch (name) {\n            case 'Input':\n                this.visitNg2Input(decorator.parent, decorator, getDecoratorStringArgs(decorator));\n                break;\n            case 'Output':\n                this.visitNg2Output(decorator.parent, decorator, getDecoratorStringArgs(decorator));\n                break;\n            case 'HostBinding':\n                this.visitNg2HostBinding(decorator.parent, decorator, getDecoratorStringArgs(decorator));\n                break;\n        }\n    };\n    Ng2Walker.prototype.visitClassDecorator = function (decorator) {\n        var name = utils_1.getDecoratorName(decorator);\n        if (!decorator.expression.arguments ||\n            !decorator.expression.arguments.length ||\n            !decorator.expression.arguments[0].properties) {\n            return;\n        }\n        if (name === 'Pipe') {\n            this.visitNg2Pipe(decorator.parent, decorator);\n        }\n    };\n    Ng2Walker.prototype.visitNg2Component = function (metadata) {\n        var template = metadata.template;\n        var getPosition = function (node) {\n            var pos = 0;\n            if (node) {\n                pos = node.pos + 1;\n                try {\n                    pos = node.getStart() + 1;\n                }\n                catch (e) { }\n            }\n            return pos;\n        };\n        if (template && template.template) {\n            try {\n                var templateAst = templateParser_1.parseTemplate(template.template.code, config_1.Config.predefinedDirectives);\n                this.visitNg2TemplateHelper(templateAst, metadata, getPosition(template.node));\n            }\n            catch (e) {\n                logger_1.logger.error('Cannot parse the template of', ((metadata.controller || {}).name || {}).text, e);\n            }\n        }\n        var styles = metadata.styles;\n        if (styles && styles.length) {\n            for (var i = 0; i < styles.length; i += 1) {\n                var style = styles[i];\n                try {\n                    this.visitNg2StyleHelper(parseCss_1.parseCss(style.style.code), metadata, style, getPosition(style.node));\n                }\n                catch (e) {\n                    logger_1.logger.error('Cannot parse the styles of', ((metadata.controller || {}).name || {}).text, e);\n                }\n            }\n        }\n    };\n    Ng2Walker.prototype.visitNg2Directive = function (metadata) { };\n    Ng2Walker.prototype.visitNg2Pipe = function (controller, decorator) { };\n    Ng2Walker.prototype.visitNg2Input = function (property, input, args) { };\n    Ng2Walker.prototype.visitNg2Output = function (property, output, args) { };\n    Ng2Walker.prototype.visitNg2HostBinding = function (property, decorator, args) { };\n    Ng2Walker.prototype.visitNg2HostListener = function (method, decorator, args) { };\n    Ng2Walker.prototype.visitNg2TemplateHelper = function (roots, context, baseStart) {\n        var _this = this;\n        if (!roots || !roots.length) {\n            return;\n        }\n        else {\n            var sourceFile = this.getContextSourceFile(context.template.url, context.template.template.source);\n            var referenceVisitor = new referenceCollectorVisitor_1.ReferenceCollectorVisitor();\n            var visitor = new this._config.templateVisitorCtrl(sourceFile, this._originalOptions, context, baseStart, this._config.expressionVisitorCtrl);\n            compiler.templateVisitAll(referenceVisitor, roots, null);\n            visitor._variables = referenceVisitor.variables;\n            compiler.templateVisitAll(visitor, roots, context.controller);\n            visitor.getFailures().forEach(function (f) { return _this.addFailure(f); });\n        }\n    };\n    Ng2Walker.prototype.visitNg2StyleHelper = function (style, context, styleMetadata, baseStart) {\n        var _this = this;\n        if (!style) {\n            return;\n        }\n        else {\n            var sourceFile = this.getContextSourceFile(styleMetadata.url, styleMetadata.style.source);\n            var visitor = new this._config.cssVisitorCtrl(sourceFile, this._originalOptions, context, styleMetadata, baseStart);\n            style.visit(visitor);\n            visitor.getFailures().forEach(function (f) { return _this.addFailure(f); });\n        }\n    };\n    Ng2Walker.prototype.getContextSourceFile = function (path, content) {\n        var current = this.getSourceFile();\n        if (!path) {\n            return current;\n        }\n        return ts.createSourceFile(path, \"`\" + content + \"`\", ts.ScriptTarget.ES5);\n    };\n    return Ng2Walker;\n}(Lint.RuleWalker));\nexports.Ng2Walker = Ng2Walker;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/componentSelectorRule.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar selectorNameBase_1 = require(\"./selectorNameBase\");\nvar Lint = require(\"tslint\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        var _this = _super.apply(this, arguments) || this;\n        _this.handleType = 'Component';\n        return _this;\n    }\n    Rule.prototype.getTypeFailure = function () { return 'The selector of the component \"%s\" should be used as %s (https://goo.gl/llsqKR)'; };\n    Rule.prototype.getNameFailure = function () { return 'The selector of the component \"%s\" should be named %s (https://goo.gl/mBg67Z)'; };\n    Rule.prototype.getSinglePrefixFailure = function () { return 'The selector of the component \"%s\" should have prefix \"%s\" (https://goo.gl/cix8BY)'; };\n    Rule.prototype.getManyPrefixFailure = function () { return 'The selector of the component \"%s\" should have one of the prefixes: %s (https://goo.gl/cix8BY)'; };\n    return Rule;\n}(selectorNameBase_1.SelectorRule));\nRule.metadata = {\n    ruleName: 'component-selector',\n    type: 'style',\n    description: \"Component selectors should follow given naming rules.\",\n    descriptionDetails: \"See more at https://angular.io/styleguide#!#02-07, https://angular.io/styleguide#!#05-02, \" +\n        \"and https://angular.io/styleguide#!#05-03.\",\n    rationale: (_a = [\"\\n    * Consistent conventions make it easy to quickly identify and reference assets of different types.\\n    * Makes it easier to promote and share the component in other apps.\\n    * Components are easy to identify in the DOM.\\n    * Keeps the element names consistent with the specification for Custom Elements.\\n    * Components have templates containing HTML and optional Angular template syntax.\\n        * They display content. Developers place components on the page as they would native HTML elements and WebComponents.\\n    * It is easier to recognize that a symbol is a component by looking at the template's HTML.\\n    \"], _a.raw = [\"\\n    * Consistent conventions make it easy to quickly identify and reference assets of different types.\\n    * Makes it easier to promote and share the component in other apps.\\n    * Components are easy to identify in the DOM.\\n    * Keeps the element names consistent with the specification for Custom Elements.\\n    * Components have templates containing HTML and optional Angular template syntax.\\n        * They display content. Developers place components on the page as they would native HTML elements and WebComponents.\\n    * It is easier to recognize that a symbol is a component by looking at the template's HTML.\\n    \"], Lint.Utils.dedent(_a)),\n    options: {\n        'type': 'array',\n        'items': [\n            {\n                'enum': ['element', 'attribute']\n            },\n            {\n                'oneOf': [\n                    {\n                        'type': 'array',\n                        'items': {\n                            'type': 'string'\n                        }\n                    },\n                    {\n                        'type': 'string'\n                    }\n                ]\n            },\n            {\n                'enum': ['kebab-case', 'camelCase']\n            }\n        ],\n        'minItems': 3,\n        'maxItems': 3\n    },\n    optionExamples: [\n        \"[\\\"element\\\", \\\"my-prefix\\\", \\\"kebab-case\\\"]\",\n        \"[\\\"element\\\", [\\\"ng\\\", \\\"ngx\\\"], \\\"kebab-case\\\"]\",\n        \"[\\\"attribute\\\", \\\"myPrefix\\\", \\\"camelCase\\\"]\",\n    ],\n    optionsDescription: (_b = [\"\\n    Options accept three obligatory items as an array:\\n    \\n    1. `\\\"element\\\"` or `\\\"attribute\\\"` forces components either to be elements or attributes.\\n    2. A single prefix (string) or array of prefixes (strings) which have to be used in component selectors.\\n    3. `\\\"kebab-case\\\"` or `\\\"camelCase\\\"` allows you to pick a case.\\n    \"], _b.raw = [\"\\n    Options accept three obligatory items as an array:\\n    \\n    1. \\\\`\\\"element\\\"\\\\` or \\\\`\\\"attribute\\\"\\\\` forces components either to be elements or attributes.\\n    2. A single prefix (string) or array of prefixes (strings) which have to be used in component selectors.\\n    3. \\\\`\\\"kebab-case\\\"\\\\` or \\\\`\\\"camelCase\\\"\\\\` allows you to pick a case.\\n    \"], Lint.Utils.dedent(_b)),\n    typescriptOnly: true,\n};\nexports.Rule = Rule;\nvar _a, _b;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/selectorNameBase.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Lint = require(\"tslint\");\nvar selectorValidator_1 = require(\"./util/selectorValidator\");\nvar sprintf_js_1 = require(\"sprintf-js\");\nvar compiler = require(\"@angular/compiler\");\nvar SyntaxKind = require(\"./util/syntaxKind\");\nvar SelectorRule = (function (_super) {\n    __extends(SelectorRule, _super);\n    function SelectorRule(ruleName, value, disabledIntervals) {\n        var _this;\n        var type = value[1];\n        var prefix = value[2] || [];\n        var name = value[3];\n        _this = _super.call(this, ruleName, value, disabledIntervals) || this;\n        _this.setMultiPrefix(prefix);\n        _this.setPrefixArguments(prefix);\n        _this.setPrefixValidator(prefix, name);\n        _this.setPrefixFailure();\n        _this.setTypeValidator(type);\n        _this.setNameValidator(name);\n        return _this;\n    }\n    SelectorRule.prototype.getPrefixFailure = function () {\n        return this.FAILURE_PREFIX;\n    };\n    SelectorRule.prototype.validateType = function (selector) {\n        return this.typeValidator(selector);\n    };\n    SelectorRule.prototype.validateName = function (selector) {\n        var _this = this;\n        if (this.isMultiSelectors) {\n            return selector.some(function (a) { return _this.nameValidator(a); });\n        }\n        else {\n            return this.nameValidator(selector);\n        }\n    };\n    SelectorRule.prototype.validatePrefix = function (selector) {\n        var _this = this;\n        if (this.isMultiSelectors) {\n            return selector.some(function (a) { return _this.prefixValidator(a); });\n        }\n        else {\n            return this.prefixValidator(selector);\n        }\n    };\n    SelectorRule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new SelectorValidatorWalker(sourceFile, this));\n    };\n    SelectorRule.prototype.setNameValidator = function (name) {\n        if (name === 'camelCase') {\n            this.nameValidator = selectorValidator_1.SelectorValidator.camelCase;\n        }\n        else if (name === 'kebab-case') {\n            this.nameValidator = selectorValidator_1.SelectorValidator.kebabCase;\n        }\n    };\n    SelectorRule.prototype.setMultiPrefix = function (prefix) {\n        this.isMultiPrefix = typeof prefix === 'string';\n    };\n    SelectorRule.prototype.setPrefixArguments = function (prefix) {\n        this.prefixArguments = this.isMultiPrefix ? prefix : prefix.join(',');\n    };\n    SelectorRule.prototype.setPrefixValidator = function (prefix, name) {\n        var prefixExpression = this.isMultiPrefix ? prefix : (prefix || []).join('|');\n        this.prefixValidator = selectorValidator_1.SelectorValidator.prefix(prefixExpression, name);\n    };\n    SelectorRule.prototype.setPrefixFailure = function () {\n        this.FAILURE_PREFIX = this.isMultiPrefix ? this.getSinglePrefixFailure() : this.getManyPrefixFailure();\n    };\n    SelectorRule.prototype.setTypeValidator = function (type) {\n        if (type === 'element') {\n            this.typeValidator = selectorValidator_1.SelectorValidator.element;\n            this.isMultiSelectors = false;\n            this.cssSelectorProperty = 'element';\n        }\n        else if (type === 'attribute') {\n            this.typeValidator = selectorValidator_1.SelectorValidator.attribute;\n            this.isMultiSelectors = true;\n            this.cssSelectorProperty = 'attrs';\n        }\n    };\n    return SelectorRule;\n}(Lint.Rules.AbstractRule));\nexports.SelectorRule = SelectorRule;\nvar SelectorValidatorWalker = (function (_super) {\n    __extends(SelectorValidatorWalker, _super);\n    function SelectorValidatorWalker(sourceFile, rule) {\n        var _this = _super.call(this, sourceFile, rule.getOptions()) || this;\n        _this.rule = rule;\n        return _this;\n    }\n    SelectorValidatorWalker.prototype.visitClassDeclaration = function (node) {\n        (node.decorators || [])\n            .forEach(this.validateDecorator.bind(this, node.name.text));\n        _super.prototype.visitClassDeclaration.call(this, node);\n    };\n    SelectorValidatorWalker.prototype.validateDecorator = function (className, decorator) {\n        var baseExpr = decorator.expression || {};\n        var expr = baseExpr.expression || {};\n        var name = expr.text;\n        var args = baseExpr.arguments || [];\n        var arg = args[0];\n        if (this.rule.handleType === name) {\n            this.validateSelector(className, arg);\n        }\n    };\n    SelectorValidatorWalker.prototype.validateSelector = function (className, arg) {\n        var _this = this;\n        if (arg.kind === SyntaxKind.current().ObjectLiteralExpression) {\n            arg.properties.filter(function (prop) { return _this.validateProperty(prop); })\n                .map(function (prop) { return prop.initializer; })\n                .forEach(function (i) {\n                var selectors = _this.extractMainSelector(i);\n                var validateSelectors = function (cb) {\n                    return !selectors.every(function (selector) {\n                        return !cb(selector[_this.rule.cssSelectorProperty]);\n                    });\n                };\n                if (!validateSelectors(_this.rule.validateType.bind(_this.rule))) {\n                    var error = sprintf_js_1.sprintf(_this.rule.getTypeFailure(), className, _this.rule.getOptions().ruleArguments[0]);\n                    _this.addFailure(_this.createFailure(i.getStart(), i.getWidth(), error));\n                }\n                else if (!validateSelectors(_this.rule.validateName.bind(_this.rule))) {\n                    var name_1 = _this.rule.getOptions().ruleArguments[2];\n                    if (name_1 === 'kebab-case') {\n                        name_1 += ' and include dash';\n                    }\n                    var error = sprintf_js_1.sprintf(_this.rule.getNameFailure(), className, name_1);\n                    _this.addFailure(_this.createFailure(i.getStart(), i.getWidth(), error));\n                }\n                else if (!validateSelectors(_this.rule.validatePrefix.bind(_this.rule))) {\n                    var error = sprintf_js_1.sprintf(_this.rule.getPrefixFailure(), className, _this.rule.prefixArguments);\n                    _this.addFailure(_this.createFailure(i.getStart(), i.getWidth(), error));\n                }\n            });\n        }\n    };\n    SelectorValidatorWalker.prototype.validateProperty = function (p) {\n        return p.name.text === 'selector' && p.initializer && this.isSupportedKind(p.initializer.kind);\n    };\n    SelectorValidatorWalker.prototype.isSupportedKind = function (kind) {\n        var current = SyntaxKind.current();\n        return [current.StringLiteral, current.NoSubstitutionTemplateLiteral].some(function (kindType) { return kindType === kind; });\n    };\n    SelectorValidatorWalker.prototype.extractMainSelector = function (i) {\n        return compiler.CssSelector.parse(i.text);\n    };\n    return SelectorValidatorWalker;\n}(Lint.RuleWalker));\nexports.SelectorValidatorWalker = SelectorValidatorWalker;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/util/selectorValidator.js":"\"use strict\";\nexports.SelectorValidator = {\n    attribute: function (selector) {\n        return selector.length !== 0;\n    },\n    element: function (selector) {\n        return selector !== null;\n    },\n    kebabCase: function (selector) {\n        return /^[a-z0-9\\-]+\\-[a-z0-9\\-]+$/.test(selector);\n    },\n    camelCase: function (selector) {\n        return /^[a-zA-Z0-9\\[\\]]+$/.test(selector);\n    },\n    prefix: function (prefix, selectorType) {\n        var regex = new RegExp(\"^\\\\[?(\" + prefix + \")\");\n        return function (selector) {\n            if (!prefix) {\n                return true;\n            }\n            if (!regex.test(selector)) {\n                return false;\n            }\n            else {\n                var suffix = selector.replace(regex, '');\n                if (selectorType === 'camelCase') {\n                    return !suffix || suffix[0] === suffix[0].toUpperCase();\n                }\n                else if (selectorType === 'kebab-case') {\n                    return !suffix || suffix[0] === '-';\n                }\n                else {\n                    throw new Error('Invalid selector type');\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/directiveClassSuffixRule.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Lint = require(\"tslint\");\nvar sprintf_js_1 = require(\"sprintf-js\");\nvar ng2Walker_1 = require(\"./angular/ng2Walker\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super.apply(this, arguments) || this;\n    }\n    Rule.validate = function (className, suffix) {\n        return className.endsWith(suffix);\n    };\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new ClassMetadataWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nRule.metadata = {\n    ruleName: 'directive-class-suffix',\n    type: 'style',\n    description: \"Classes decorated with @Directive must have suffix \\\"Directive\\\" (or custom) in their name.\",\n    descriptionDetails: \"See more at https://angular.io/styleguide#!#02-03.\",\n    rationale: \"Consistent conventions make it easy to quickly identify and reference assets of different types.\",\n    options: {\n        type: 'array',\n        items: {\n            type: 'string',\n        }\n    },\n    optionExamples: [\n        \"true\",\n        \"[true, \\\"Directive\\\", \\\"MySuffix\\\"]\",\n    ],\n    optionsDescription: \"Supply a list of allowed component suffixes. Defaults to \\\"Directive\\\".\",\n    typescriptOnly: true,\n};\nRule.FAILURE = 'The name of the class %s should end with the suffix %s (https://goo.gl/5X1TE7)';\nexports.Rule = Rule;\nvar ClassMetadataWalker = (function (_super) {\n    __extends(ClassMetadataWalker, _super);\n    function ClassMetadataWalker() {\n        return _super.apply(this, arguments) || this;\n    }\n    ClassMetadataWalker.prototype.visitNg2Directive = function (meta) {\n        var name = meta.controller.name;\n        var className = name.text;\n        var suffix = this.getOptions()[0] || 'Directive';\n        if (!Rule.validate(className, suffix)) {\n            this.addFailure(this.createFailure(name.getStart(), name.getWidth(), sprintf_js_1.sprintf.apply(this, [Rule.FAILURE, className, suffix])));\n        }\n    };\n    return ClassMetadataWalker;\n}(ng2Walker_1.Ng2Walker));\nexports.ClassMetadataWalker = ClassMetadataWalker;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/directiveSelectorRule.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar selectorNameBase_1 = require(\"./selectorNameBase\");\nvar Lint = require(\"tslint\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        var _this = _super.apply(this, arguments) || this;\n        _this.handleType = 'Directive';\n        return _this;\n    }\n    Rule.prototype.getTypeFailure = function () { return 'The selector of the directive \"%s\" should be used as %s (https://goo.gl/QS8kEs)'; };\n    Rule.prototype.getNameFailure = function () { return 'The selector of the directive \"%s\" should be named %s (https://goo.gl/QS8kEs)'; };\n    Rule.prototype.getSinglePrefixFailure = function () { return 'The selector of the directive \"%s\" should have prefix \"%s\" (https://goo.gl/uacjKR)'; };\n    Rule.prototype.getManyPrefixFailure = function () { return 'The selector of the directive \"%s\" should have one of the prefixes: %s (https://goo.gl/uacjKR)'; };\n    return Rule;\n}(selectorNameBase_1.SelectorRule));\nRule.metadata = {\n    ruleName: 'directive-selector',\n    type: 'style',\n    description: \"Directive selectors should follow given naming rules.\",\n    descriptionDetails: \"See more at https://angular.io/styleguide#!#02-07, https://angular.io/styleguide#!#05-02, \" +\n        \"and https://angular.io/styleguide#!#05-03.\",\n    rationale: (_a = [\"\\n    * Consistent conventions make it easy to quickly identify and reference assets of different types.\\n    * Makes it easier to promote and share the directive in other apps.\\n    * Directives are easy to identify in the DOM.\\n    * It is easier to recognize that a symbol is a directive by looking at the template's HTML.\\n    \"], _a.raw = [\"\\n    * Consistent conventions make it easy to quickly identify and reference assets of different types.\\n    * Makes it easier to promote and share the directive in other apps.\\n    * Directives are easy to identify in the DOM.\\n    * It is easier to recognize that a symbol is a directive by looking at the template's HTML.\\n    \"], Lint.Utils.dedent(_a)),\n    options: {\n        'type': 'array',\n        'items': [\n            {\n                'enum': ['element', 'attribute']\n            },\n            {\n                'oneOf': [\n                    {\n                        'type': 'array',\n                        'items': {\n                            'type': 'string'\n                        }\n                    },\n                    {\n                        'type': 'string'\n                    }\n                ]\n            },\n            {\n                'enum': ['kebab-case', 'camelCase']\n            }\n        ],\n        'minItems': 3,\n        'maxItems': 3\n    },\n    optionExamples: [\n        \"[\\\"element\\\", \\\"my-prefix\\\", \\\"kebab-case\\\"]\",\n        \"[\\\"element\\\", [\\\"ng\\\", \\\"ngx\\\"], \\\"kebab-case\\\"]\",\n        \"[\\\"attribute\\\", \\\"myPrefix\\\", \\\"camelCase\\\"]\",\n    ],\n    optionsDescription: (_b = [\"\\n    Options accept three obligatory items as an array:\\n    \\n    1. `\\\"element\\\"` or `\\\"attribute\\\"` forces components either to be elements or attributes.\\n    2. A single prefix (string) or array of prefixes (strings) which have to be used in directive selectors.\\n    3. `\\\"kebab-case\\\"` or `\\\"camelCase\\\"` allows you to pick a case.\\n    \"], _b.raw = [\"\\n    Options accept three obligatory items as an array:\\n    \\n    1. \\\\`\\\"element\\\"\\\\` or \\\\`\\\"attribute\\\"\\\\` forces components either to be elements or attributes.\\n    2. A single prefix (string) or array of prefixes (strings) which have to be used in directive selectors.\\n    3. \\\\`\\\"kebab-case\\\"\\\\` or \\\\`\\\"camelCase\\\"\\\\` allows you to pick a case.\\n    \"], Lint.Utils.dedent(_b)),\n    typescriptOnly: true,\n};\nexports.Rule = Rule;\nvar _a, _b;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/importDestructuringSpacingRule.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ts = require(\"typescript\");\nvar Lint = require(\"tslint\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new ImportDestructuringSpacingWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nRule.metadata = {\n    ruleName: 'import-destructing-spacing-rule',\n    type: 'style',\n    description: \"Ensure consistent and tidy imports.\",\n    rationale: \"Imports are easier for the reader to look at when they're tidy.\",\n    options: null,\n    optionsDescription: \"Not configurable.\",\n    typescriptOnly: true,\n};\nRule.FAILURE_STRING = 'You need to leave whitespaces inside of the import statement\\'s curly braces';\nexports.Rule = Rule;\nvar ImportDestructuringSpacingWalker = (function (_super) {\n    __extends(ImportDestructuringSpacingWalker, _super);\n    function ImportDestructuringSpacingWalker(sourceFile, options) {\n        var _this = _super.call(this, sourceFile, options) || this;\n        _this.scanner = ts.createScanner(ts.ScriptTarget.ES5, false, ts.LanguageVariant.Standard, sourceFile.text);\n        return _this;\n    }\n    ImportDestructuringSpacingWalker.prototype.visitImportDeclaration = function (node) {\n        var importClause = node.importClause;\n        if (importClause && importClause.namedBindings) {\n            var text = importClause.namedBindings.getText();\n            if (!this.checkForWhiteSpace(text)) {\n                this.addFailure(this.createFailure(importClause.namedBindings.getStart(), importClause.namedBindings.getWidth(), Rule.FAILURE_STRING));\n            }\n        }\n        _super.prototype.visitImportDeclaration.call(this, node);\n    };\n    ImportDestructuringSpacingWalker.prototype.checkForWhiteSpace = function (text) {\n        if (/\\s*\\*\\s+as\\s+[^\\s]/.test(text)) {\n            return true;\n        }\n        return /{\\s[^]*\\s}/.test(text);\n    };\n    return ImportDestructuringSpacingWalker;\n}(Lint.SkippableTokenAwareRuleWalker));\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/invokeInjectableRule.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Lint = require(\"tslint\");\nvar ng2Walker_1 = require(\"./angular/ng2Walker\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new ValidateInjectableWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nRule.metadata = {\n    ruleName: 'invoke-injectable',\n    type: 'functionality',\n    description: \"Ensures that @Injectable decorator is properly invoked.\",\n    rationale: \"Application will fail mysteriously if we forget the parentheses.\",\n    options: null,\n    optionsDescription: \"Not configurable.\",\n    typescriptOnly: true,\n};\nRule.FAILURE_STRING = 'You have to invoke @Injectable()';\nexports.Rule = Rule;\nvar ValidateInjectableWalker = (function (_super) {\n    __extends(ValidateInjectableWalker, _super);\n    function ValidateInjectableWalker() {\n        return _super.apply(this, arguments) || this;\n    }\n    ValidateInjectableWalker.prototype.visitClassDeclaration = function (declaration) {\n        var _this = this;\n        (declaration.decorators || [])\n            .forEach(function (d) {\n            if (d.expression && d.expression.text === 'Injectable') {\n                _this.addFailure(_this.createFailure(d.getStart(), d.getWidth(), Rule.FAILURE_STRING));\n            }\n        });\n    };\n    return ValidateInjectableWalker;\n}(ng2Walker_1.Ng2Walker));\nexports.ValidateInjectableWalker = ValidateInjectableWalker;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/noAccessMissingMemberRule.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Lint = require(\"tslint\");\nvar sprintf_js_1 = require(\"sprintf-js\");\nvar utils_1 = require(\"./util/utils\");\nvar ng2Walker_1 = require(\"./angular/ng2Walker\");\nvar recursiveAngularExpressionVisitor_1 = require(\"./angular/templates/recursiveAngularExpressionVisitor\");\nvar expressionTypes_1 = require(\"./angular/expressionTypes\");\nvar classDeclarationUtils_1 = require(\"./util/classDeclarationUtils\");\nvar DeclarationType;\n(function (DeclarationType) {\n    DeclarationType[DeclarationType[\"Property\"] = 0] = \"Property\";\n    DeclarationType[DeclarationType[\"Method\"] = 1] = \"Method\";\n})(DeclarationType || (DeclarationType = {}));\n;\nvar SymbolAccessValidator = (function (_super) {\n    __extends(SymbolAccessValidator, _super);\n    function SymbolAccessValidator() {\n        return _super.apply(this, arguments) || this;\n    }\n    SymbolAccessValidator.prototype.visitPropertyRead = function (ast, context) {\n        return this.doCheck(ast, DeclarationType.Property, context);\n    };\n    SymbolAccessValidator.prototype.visitMethodCall = function (ast, context) {\n        this.doCheck(ast, DeclarationType.Method, context);\n    };\n    SymbolAccessValidator.prototype.visitPropertyWrite = function (ast, context) {\n        this.doCheck(ast, DeclarationType.Property, context);\n    };\n    SymbolAccessValidator.prototype.doCheck = function (ast, type, context) {\n        var symbolType;\n        var available;\n        if (type === DeclarationType.Method) {\n            symbolType = 'method';\n        }\n        else {\n            symbolType = 'property';\n        }\n        available = classDeclarationUtils_1.getDeclaredMethodNames(this.context.controller)\n            .concat(classDeclarationUtils_1.getDeclaredPropertyNames(this.context.controller))\n            .concat(this.preDefinedVariables);\n        var tmp = ast;\n        while (tmp && !expressionTypes_1.ExpTypes.ImplicitReceiver(tmp)) {\n            ast = tmp;\n            if (expressionTypes_1.ExpTypes.KeyedRead(tmp)) {\n                tmp = tmp.obj;\n            }\n            else if (expressionTypes_1.ExpTypes.KeyedWrite(tmp)) {\n                tmp = tmp.obj;\n            }\n            else if (expressionTypes_1.ExpTypes.PropertyRead(tmp)) {\n                tmp = tmp.receiver;\n            }\n            else if (expressionTypes_1.ExpTypes.PropertyWrite(tmp)) {\n                tmp = tmp.receiver;\n            }\n            else if (expressionTypes_1.ExpTypes.SafeMethodCall(tmp)) {\n                tmp = tmp.receiver;\n            }\n            else if (expressionTypes_1.ExpTypes.SafePropertyRead(tmp)) {\n                tmp = tmp.receiver;\n            }\n            else if (expressionTypes_1.ExpTypes.MethodCall(tmp)) {\n                tmp = tmp.receiver;\n            }\n            else {\n                break;\n            }\n        }\n        if (available.indexOf(ast.name) < 0) {\n            var failureString = sprintf_js_1.sprintf.apply(this, [Rule.FAILURE, symbolType, ast.name]);\n            if (ast.name) {\n                var top_1 = this.getTopSuggestion(available, ast.name);\n                var getSuggestion = function (list) {\n                    if (list.length === 1) {\n                        return \"\\\"\" + list[0] + \"\\\"\";\n                    }\n                    var result = \"\\\"\" + list.shift() + \"\\\"\";\n                    while (list.length > 1) {\n                        result += \", \\\"\" + list.shift() + \"\\\"\";\n                    }\n                    result += \" or \\\"\" + list.shift() + \"\\\"\";\n                    return result;\n                };\n                if (top_1.length && top_1[0].distance <= 2) {\n                    failureString += \" Probably you mean: \" + getSuggestion(top_1.map(function (s) { return s.element; })) + \".\";\n                }\n            }\n            var width = ast.name.length;\n            this.addFailure(this.createFailure(ast.span.start, width, failureString));\n        }\n        return null;\n    };\n    SymbolAccessValidator.prototype.getTopSuggestion = function (list, current) {\n        var result = [];\n        var tmp = list.map(function (e) {\n            return {\n                element: e,\n                distance: utils_1.stringDistance(e, current)\n            };\n        }).sort(function (a, b) { return a.distance - b.distance; });\n        var first = tmp.shift();\n        if (!first) {\n            return [];\n        }\n        else {\n            result.push(first);\n            var current_1;\n            while (current_1 = tmp.shift()) {\n                if (current_1.distance !== first.distance) {\n                    return result;\n                }\n                else {\n                    result.push(current_1);\n                }\n            }\n            return result;\n        }\n    };\n    return SymbolAccessValidator;\n}(recursiveAngularExpressionVisitor_1.RecursiveAngularExpressionVisitor));\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new ng2Walker_1.Ng2Walker(sourceFile, this.getOptions(), {\n            expressionVisitorCtrl: SymbolAccessValidator\n        }));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nRule.metadata = {\n    ruleName: 'no-access-missing-member',\n    type: 'functionality',\n    description: \"Disallows using non-existing properties and methods from the component in templates.\",\n    rationale: \"Such occurances in code are most likely a result of a typo.\",\n    options: null,\n    optionsDescription: \"Not configurable.\",\n    typescriptOnly: true,\n};\nRule.FAILURE = 'The %s \"%s\" that you\\'re trying to access does not exist in the class declaration.';\nexports.Rule = Rule;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/util/utils.js":"\"use strict\";\nvar ts = require(\"typescript\");\nvar SyntaxKind = require('./syntaxKind');\nexports.stringDistance = function (s, t, ls, lt) {\n    if (ls === void 0) { ls = s.length; }\n    if (lt === void 0) { lt = t.length; }\n    var memo = [];\n    var currRowMemo;\n    var i;\n    var k;\n    for (k = 0; k <= lt; k += 1) {\n        memo[k] = k;\n    }\n    for (i = 1; i <= ls; i += 1) {\n        currRowMemo = [i];\n        for (k = 1; k <= lt; k += 1) {\n            currRowMemo[k] = Math.min(currRowMemo[k - 1] + 1, memo[k] + 1, memo[k - 1] + (s[i - 1] !== t[k - 1] ? 1 : 0));\n        }\n        memo = currRowMemo;\n    }\n    return memo[lt];\n};\nexports.isSimpleTemplateString = function (e) {\n    return e.kind === ts.SyntaxKind.StringLiteral ||\n        e.kind === SyntaxKind.current().FirstTemplateToken;\n};\nexports.getDecoratorPropertyInitializer = function (decorator, name) {\n    return decorator.expression.arguments[0]\n        .properties.map(function (prop) {\n        if (prop.name.text === name) {\n            return prop;\n        }\n        return null;\n    }).filter(function (el) { return !!el; }).map(function (prop) { return prop.initializer; }).pop();\n};\nexports.getDecoratorName = function (decorator) {\n    var baseExpr = decorator.expression || {};\n    var expr = baseExpr.expression || {};\n    return expr.text;\n};\nexports.getComponentDecorator = function (declaration) {\n    return (declaration.decorators || [])\n        .filter(function (d) {\n        if (!d.expression.arguments ||\n            !d.expression.arguments.length ||\n            !d.expression.arguments[0].properties) {\n            return false;\n        }\n        var name = exports.getDecoratorName(d);\n        if (name === 'Component') {\n            return true;\n        }\n    }).pop();\n};\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/util/syntaxKind.js":"\"use strict\";\nvar ts = require(\"typescript\");\nvar SyntaxKind;\n(function (SyntaxKind) {\n    function current() {\n        return ts.SyntaxKind;\n    }\n    SyntaxKind.current = current;\n})(SyntaxKind || (SyntaxKind = {}));\nmodule.exports = SyntaxKind;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/noAttributeParameterDecoratorRule.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Lint = require(\"tslint\");\nvar sprintf_js_1 = require(\"sprintf-js\");\nvar SyntaxKind = require(\"./util/syntaxKind\");\nvar walkerFn_1 = require(\"./walkerFactory/walkerFn\");\nvar function_1 = require(\"./util/function\");\nvar astQuery_1 = require(\"./util/astQuery\");\nvar walkerFactory_1 = require(\"./walkerFactory/walkerFactory\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super.apply(this, arguments) || this;\n    }\n    Rule.decoratorIsAttribute = function (dec) {\n        if (astQuery_1.isDecorator(dec)) {\n            return astQuery_1.callExpression(dec).bind(astQuery_1.withIdentifier('Attribute'));\n        }\n        return function_1.Maybe.nothing;\n    };\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(Rule.walkerBuilder(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nRule.metadata = {\n    ruleName: 'no-attribute-parameter-decorator-rule',\n    type: 'maintainability',\n    description: \"Disallow usage of @Attribute decorator\",\n    rationale: \"@Attribute is considered bad practice. Use @Input instead.\",\n    options: null,\n    optionsDescription: \"Not configurable.\",\n    typescriptOnly: true,\n};\nRule.FAILURE_STRING = 'In the constructor of class \"%s\",' +\n    ' the parameter \"%s\" uses the @Attribute decorator, ' +\n    'which is considered as a bad practice. Please,' +\n    ' consider construction of type \"@Input() %s: string\"';\nRule.walkerBuilder = walkerFn_1.all(walkerFn_1.validate(SyntaxKind.current().Constructor)(function (node) {\n    var syntaxKind = SyntaxKind.current();\n    return function_1.Maybe.lift(node.parent)\n        .fmap(function (parent) {\n        if (parent.kind === syntaxKind.ClassExpression) {\n            return parent.parent.name.text;\n        }\n        else if (parent.kind = syntaxKind.ClassDeclaration) {\n            return parent.name.text;\n        }\n    })\n        .bind(function (parentName) {\n        var failures = node.parameters.map(function (p) {\n            return function_1.Maybe.lift(p.decorators)\n                .bind(function (decorators) {\n                var decoratorsFailed = function_1.listToMaybe(decorators.map(function (d) { return Rule.decoratorIsAttribute(d); }));\n                return decoratorsFailed.fmap(function () {\n                    return new walkerFactory_1.Failure(p, sprintf_js_1.sprintf(Rule.FAILURE_STRING, parentName, p.name.text, p.name.text));\n                });\n            });\n        });\n        return function_1.listToMaybe(failures);\n    });\n}));\nexports.Rule = Rule;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/walkerFactory/walkerFn.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ng2Walker_1 = require(\"../angular/ng2Walker\");\nvar function_1 = require(\"../util/function\");\nfunction validate(syntaxKind) {\n    return function (validateFn) { return ({\n        kind: 'Node',\n        validate: function (node, options) { return (node.kind === syntaxKind) ? validateFn(node, options) : function_1.Maybe.nothing; },\n    }); };\n}\nexports.validate = validate;\nfunction validateComponent(validate) {\n    return {\n        kind: 'Ng2Component',\n        validate: validate,\n    };\n}\nexports.validateComponent = validateComponent;\nfunction all() {\n    var validators = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        validators[_i] = arguments[_i];\n    }\n    return function (sourceFile, options) {\n        var e = (function (_super) {\n            __extends(class_1, _super);\n            function class_1() {\n                return _super.apply(this, arguments) || this;\n            }\n            class_1.prototype.visitNg2Component = function (meta) {\n                var _this = this;\n                validators.forEach(function (v) {\n                    if (v.kind === 'Ng2Component') {\n                        v.validate(meta, _this.getOptions()).fmap(function (failures) { return failures.forEach(function (f) { return _this.failed(f); }); });\n                    }\n                });\n                _super.prototype.visitNg2Component.call(this, meta);\n            };\n            class_1.prototype.visitNode = function (node) {\n                var _this = this;\n                validators.forEach(function (v) {\n                    if (v.kind === 'Node') {\n                        v.validate(node, _this.getOptions()).fmap(function (failures) { return failures.forEach(function (f) { return _this.failed(f); }); });\n                    }\n                });\n                _super.prototype.visitNode.call(this, node);\n            };\n            class_1.prototype.failed = function (failure) {\n                this.addFailure(this.createFailure(failure.node.getStart(), failure.node.getWidth(), failure.message));\n            };\n            return class_1;\n        }(ng2Walker_1.Ng2Walker));\n        return new e(sourceFile, options);\n    };\n}\nexports.all = all;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/noForwardRefRule.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Lint = require(\"tslint\");\nvar sprintf_js_1 = require(\"sprintf-js\");\nvar SyntaxKind = require(\"./util/syntaxKind\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new ExpressionCallMetadataWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nRule.metadata = {\n    ruleName: 'no-forward-ref',\n    type: 'maintainability',\n    description: \"Disallows usage of forward references for DI.\",\n    rationale: \"The flow of DI is disrupted by using `forwardRef` and might make code more difficult to understand.\",\n    options: null,\n    optionsDescription: \"Not configurable.\",\n    typescriptOnly: true,\n};\nRule.FAILURE_IN_CLASS = 'Avoid using forwardRef in class \"%s\"';\nRule.FAILURE_IN_VARIABLE = 'Avoid using forwardRef in variable \"%s\"';\nexports.Rule = Rule;\nvar ExpressionCallMetadataWalker = (function (_super) {\n    __extends(ExpressionCallMetadataWalker, _super);\n    function ExpressionCallMetadataWalker() {\n        return _super.apply(this, arguments) || this;\n    }\n    ExpressionCallMetadataWalker.prototype.visitCallExpression = function (node) {\n        this.validateCallExpression(node);\n        _super.prototype.visitCallExpression.call(this, node);\n    };\n    ExpressionCallMetadataWalker.prototype.validateCallExpression = function (callExpression) {\n        if (callExpression.expression.text === 'forwardRef') {\n            var currentNode = callExpression;\n            while (currentNode.parent.parent) {\n                currentNode = currentNode.parent;\n            }\n            var failureConfig = [];\n            if (currentNode.kind === SyntaxKind.current().VariableStatement) {\n                failureConfig = [Rule.FAILURE_IN_VARIABLE, currentNode.declarationList.declarations[0].name.text];\n            }\n            else {\n                failureConfig = [Rule.FAILURE_IN_CLASS, currentNode.name.text];\n            }\n            this.addFailure(this.createFailure(callExpression.getStart(), callExpression.getWidth(), sprintf_js_1.sprintf.apply(this, failureConfig)));\n        }\n    };\n    return ExpressionCallMetadataWalker;\n}(Lint.RuleWalker));\nexports.ExpressionCallMetadataWalker = ExpressionCallMetadataWalker;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/noInputRenameRule.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Lint = require(\"tslint\");\nvar sprintf_js_1 = require(\"sprintf-js\");\nvar ng2Walker_1 = require(\"./angular/ng2Walker\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new InputMetadataWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nRule.metadata = {\n    ruleName: 'no-input-rename-rule',\n    type: 'maintainability',\n    description: \"Disallows renaming directive inputs by providing a string to the decorator.\",\n    descriptionDetails: \"See more at https://angular.io/styleguide#!#05-13.\",\n    rationale: \"Two names for the same property (one private, one public) is inherently confusing.\",\n    options: null,\n    optionsDescription: \"Not configurable.\",\n    typescriptOnly: true,\n};\nRule.FAILURE_STRING = 'In the class \"%s\", the directive ' +\n    'input property \"%s\" should not be renamed.' +\n    'Please, consider the following use \"@Input() %s: string\"';\nexports.Rule = Rule;\nvar InputMetadataWalker = (function (_super) {\n    __extends(InputMetadataWalker, _super);\n    function InputMetadataWalker() {\n        return _super.apply(this, arguments) || this;\n    }\n    InputMetadataWalker.prototype.visitNg2Input = function (property, input, args) {\n        var className = property.parent.name.text;\n        var memberName = property.name.text;\n        if (args.length !== 0 && memberName !== args[0]) {\n            var failureConfig = [className, memberName, memberName];\n            failureConfig.unshift(Rule.FAILURE_STRING);\n            this.addFailure(this.createFailure(property.getStart(), property.getWidth(), sprintf_js_1.sprintf.apply(this, failureConfig)));\n        }\n    };\n    return InputMetadataWalker;\n}(ng2Walker_1.Ng2Walker));\nexports.InputMetadataWalker = InputMetadataWalker;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/noOutputRenameRule.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Lint = require(\"tslint\");\nvar sprintf_js_1 = require(\"sprintf-js\");\nvar ng2Walker_1 = require(\"./angular/ng2Walker\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new OutputMetadataWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nRule.metadata = {\n    ruleName: 'no-output-rename-rule',\n    type: 'maintainability',\n    description: \"Disallows renaming directive outputs by providing a string to the decorator.\",\n    descriptionDetails: \"See more at https://angular.io/styleguide#!#05-13.\",\n    rationale: \"Two names for the same property (one private, one public) is inherently confusing.\",\n    options: null,\n    optionsDescription: \"Not configurable.\",\n    typescriptOnly: true,\n};\nRule.FAILURE_STRING = 'In the class \"%s\", the directive output ' +\n    'property \"%s\" should not be renamed.' +\n    'Please, consider the following use \"@Output() %s = new EventEmitter();\"';\nexports.Rule = Rule;\nvar OutputMetadataWalker = (function (_super) {\n    __extends(OutputMetadataWalker, _super);\n    function OutputMetadataWalker() {\n        return _super.apply(this, arguments) || this;\n    }\n    OutputMetadataWalker.prototype.visitNg2Output = function (property, output, args) {\n        var className = property.parent.name.text;\n        var memberName = property.name.text;\n        if (args.length !== 0 && memberName !== args[0]) {\n            var failureConfig = [className, memberName, memberName];\n            failureConfig.unshift(Rule.FAILURE_STRING);\n            this.addFailure(this.createFailure(property.getStart(), property.getWidth(), sprintf_js_1.sprintf.apply(this, failureConfig)));\n        }\n    };\n    return OutputMetadataWalker;\n}(ng2Walker_1.Ng2Walker));\nexports.OutputMetadataWalker = OutputMetadataWalker;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/noUnusedCssRule.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Lint = require(\"tslint\");\nvar ng2Walker_1 = require(\"./angular/ng2Walker\");\nvar utils_1 = require(\"./util/utils\");\nvar basicCssAstVisitor_1 = require(\"./angular/styles/basicCssAstVisitor\");\nvar basicTemplateAstVisitor_1 = require(\"./angular/templates/basicTemplateAstVisitor\");\nvar compiler_1 = require(\"@angular/compiler\");\nvar templateParser_1 = require(\"./angular/templates/templateParser\");\nvar logger_1 = require(\"./util/logger\");\nvar ngVersion_1 = require(\"./util/ngVersion\");\nvar CssSelectorTokenizer = require('css-selector-tokenizer');\nvar getSymbolName = function (t) {\n    var expr = t;\n    if (t.expression) {\n        expr = t.expression;\n    }\n    if (t.expression && t.expression.name) {\n        expr = t.expression.name;\n    }\n    return expr.text;\n};\nvar isEncapsulationEnabled = function (encapsulation) {\n    if (!encapsulation) {\n        return true;\n    }\n    else {\n        if (getSymbolName(encapsulation) !== 'ViewEncapsulation') {\n            return false;\n        }\n        else {\n            var encapsulationType = encapsulation.name.text;\n            if (/^(Emulated|Native)$/.test(encapsulationType)) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\nvar lang = require('cssauron')({\n    tag: function (node) {\n        return (node.name || '').toLowerCase();\n    },\n    contents: function (node) { return ''; },\n    id: function (node) {\n        return this.attr(node, 'id');\n    },\n    'class': function (node) {\n        var classBindings = (node.inputs || [])\n            .filter(function (b) { return b.type === compiler_1.PropertyBindingType.Class; })\n            .map(function (b) { return b.name; }).join(' ');\n        var classAttr = node.attrs.filter(function (a) { return a.name.toLowerCase() === 'class'; }).pop();\n        var staticClasses = '';\n        if (classAttr) {\n            staticClasses = classAttr.value + ' ';\n        }\n        return staticClasses + classBindings;\n    },\n    parent: function (node) {\n        return node.parentNode;\n    },\n    children: function (node) {\n        return node.children;\n    },\n    attr: function (node, attr) {\n        var targetAttr = node.attrs.filter(function (a) { return a.name === attr; }).pop();\n        if (targetAttr) {\n            return targetAttr.value;\n        }\n        return undefined;\n    }\n});\nvar ElementVisitor = (function (_super) {\n    __extends(ElementVisitor, _super);\n    function ElementVisitor() {\n        return _super.apply(this, arguments) || this;\n    }\n    ElementVisitor.prototype.visitElement = function (ast, fn) {\n        var _this = this;\n        fn(ast);\n        ast.children.forEach(function (c) {\n            if (c instanceof compiler_1.ElementAst) {\n                c.parentNode = ast;\n            }\n            _this.visit(c, fn);\n        });\n    };\n    return ElementVisitor;\n}(basicTemplateAstVisitor_1.BasicTemplateAstVisitor));\nvar hasSelector = function (s, type) {\n    if (!s) {\n        return false;\n    }\n    if (s.type === 'selector' || s.type === 'selectors') {\n        return (s.nodes || []).some(function (n) { return hasSelector(n, type); });\n    }\n    else {\n        return s.type === type;\n    }\n};\nvar dynamicFilters = {\n    id: function (ast, selector) {\n        return (ast.inputs || []).some(function (i) { return i.name === 'id'; });\n    },\n    attribute: function (ast, selector) {\n        return (ast.inputs || []).some(function (i) { return i.type === compiler_1.PropertyBindingType.Attribute; });\n    },\n    'class': function (ast, selector) {\n        return (ast.inputs || []).some(function (i) { return i.name === 'className' || i.name === 'ngClass'; });\n    }\n};\nvar ElementFilterVisitor = (function (_super) {\n    __extends(ElementFilterVisitor, _super);\n    function ElementFilterVisitor() {\n        return _super.apply(this, arguments) || this;\n    }\n    ElementFilterVisitor.prototype.shouldVisit = function (ast, strategies, selectorTypes) {\n        var _this = this;\n        return Object.keys(strategies).every(function (s) {\n            var strategy = strategies[s];\n            return !selectorTypes[s] || !strategy(ast);\n        }) && (ast.children || [])\n            .every(function (c) { return ast instanceof compiler_1.ElementAst && _this.shouldVisit(c, strategies, selectorTypes)\n            || ast instanceof compiler_1.EmbeddedTemplateAst &&\n                (ast.children || []).every(function (c) { return _this.shouldVisit(c, strategies, selectorTypes); }); });\n    };\n    return ElementFilterVisitor;\n}(basicTemplateAstVisitor_1.BasicTemplateAstVisitor));\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new UnusedCssNg2Visitor(sourceFile, this.getOptions(), {\n            cssVisitorCtrl: UnusedCssVisitor\n        }));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nRule.metadata = {\n    ruleName: 'no-unused-css-rule',\n    type: 'maintainability',\n    description: \"Disallows having an unused CSS rule in the component's stylesheet.\",\n    options: null,\n    optionsDescription: \"Not configurable.\",\n    typescriptOnly: true,\n};\nRule.FAILURE = 'The %s \"%s\" that you\\'re trying to access does not exist in the class declaration.';\nexports.Rule = Rule;\nvar UnusedCssVisitor = (function (_super) {\n    __extends(UnusedCssVisitor, _super);\n    function UnusedCssVisitor(sourceFile, originalOptions, context, style, templateStart) {\n        var _this = _super.call(this, sourceFile, originalOptions, context, style, templateStart) || this;\n        _this.style = style;\n        return _this;\n    }\n    UnusedCssVisitor.prototype.visitCssSelectorRule = function (ast) {\n        var _this = this;\n        try {\n            var match = ast.selectors.some(function (s) { return _this.visitCssSelector(s); });\n            if (!match) {\n                var start = ast.start.offset;\n                var end = ast.end.offset;\n                var length_1 = end - ast.start.offset + 1;\n                var fix = this.createFix(this.createReplacement(start, length_1, ''));\n                this.addFailure(this.createFailure(start, length_1, 'Unused styles', fix));\n            }\n        }\n        catch (e) {\n            logger_1.logger.error(e);\n        }\n        return true;\n    };\n    UnusedCssVisitor.prototype.visitCssSelector = function (ast) {\n        var parts = [];\n        for (var i = 0; i < ast.selectorParts.length; i += 1) {\n            var c = ast.selectorParts[i];\n            c.strValue = c.strValue.split('::').shift();\n            if (c.strValue.endsWith('/') ||\n                c.strValue.endsWith('>')) {\n                parts.push(c.strValue);\n                break;\n            }\n            else if (!c.strValue.startsWith(':')) {\n                parts.push(c.strValue);\n            }\n        }\n        if (!parts.length || !this.templateAst) {\n            return true;\n        }\n        var strippedSelector = parts.map(function (s) { return s.replace(/\\/|>$/, '').trim(); }).join(' ');\n        var elementFilterVisitor = new ElementFilterVisitor(this.getSourceFile(), this._originalOptions, this.context, 0);\n        var tokenized = CssSelectorTokenizer.parse(strippedSelector);\n        var selectorTypesCache = Object.keys(dynamicFilters).reduce(function (a, key) {\n            a[key] = hasSelector(tokenized, key);\n            return a;\n        }, {});\n        if (!elementFilterVisitor.shouldVisit(this.templateAst, dynamicFilters, selectorTypesCache)) {\n            return true;\n        }\n        var matchFound = false;\n        var selector = function (element) {\n            if (lang(strippedSelector)(element)) {\n                matchFound = true;\n                return true;\n            }\n            return false;\n        };\n        var visitor = new ElementVisitor(this.getSourceFile(), this._originalOptions, this.context, 0);\n        visitor.visit(this.templateAst, selector);\n        return matchFound;\n    };\n    return UnusedCssVisitor;\n}(basicCssAstVisitor_1.BasicCssAstVisitor));\nvar UnusedCssNg2Visitor = (function (_super) {\n    __extends(UnusedCssNg2Visitor, _super);\n    function UnusedCssNg2Visitor() {\n        return _super.apply(this, arguments) || this;\n    }\n    UnusedCssNg2Visitor.prototype.visitClassDeclaration = function (declaration) {\n        var _this = this;\n        var d = utils_1.getComponentDecorator(declaration);\n        if (d) {\n            var meta_1 = this._metadataReader.read(declaration);\n            this.visitNg2Component(meta_1);\n            if (meta_1.template && meta_1.template.template) {\n                try {\n                    var ElementAstCtr_1 = compiler_1.ElementAst;\n                    ngVersion_1.SemVerDSL\n                        .gte('4.0.0-beta.8', function () {\n                        _this.templateAst =\n                            new ElementAstCtr_1('*', [], [], [], [], [], [], false, [], templateParser_1.parseTemplate(meta_1.template.template.code), 0, null, null);\n                    })\n                        .else(function () {\n                        _this.templateAst =\n                            new ElementAstCtr_1('*', [], [], [], [], [], [], false, templateParser_1.parseTemplate(meta_1.template.template.code), 0, null, null);\n                    });\n                }\n                catch (e) {\n                    logger_1.logger.error('Cannot parse the template', e);\n                }\n            }\n        }\n        _super.prototype.visitClassDeclaration.call(this, declaration);\n    };\n    UnusedCssNg2Visitor.prototype.visitNg2StyleHelper = function (style, context, styleMetadata, baseStart) {\n        var _this = this;\n        if (!style) {\n            return;\n        }\n        else {\n            var file = this.getContextSourceFile(styleMetadata.url, styleMetadata.style.source);\n            var visitor = new UnusedCssVisitor(file, this._originalOptions, context, styleMetadata, baseStart);\n            visitor.templateAst = this.templateAst;\n            var d = utils_1.getComponentDecorator(context.controller);\n            var encapsulation = utils_1.getDecoratorPropertyInitializer(d, 'encapsulation');\n            if (isEncapsulationEnabled(encapsulation)) {\n                style.visit(visitor);\n                visitor.getFailures().forEach(function (f) { return _this.addFailure(f); });\n            }\n        }\n    };\n    return UnusedCssNg2Visitor;\n}(ng2Walker_1.Ng2Walker));\nexports.UnusedCssNg2Visitor = UnusedCssNg2Visitor;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/pipeImpureRule.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Lint = require(\"tslint\");\nvar sprintf_js_1 = require(\"sprintf-js\");\nvar ng2Walker_1 = require(\"./angular/ng2Walker\");\nvar SyntaxKind = require(\"./util/syntaxKind\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new ClassMetadataWalker(sourceFile, this));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nRule.metadata = {\n    ruleName: 'pipe-impure',\n    type: 'functionality',\n    description: \"Pipes cannot be declared as impure.\",\n    rationale: \"Impure pipes do not perform well because they are run on every change detection cycle.\",\n    options: null,\n    optionsDescription: \"Not configurable.\",\n    typescriptOnly: true,\n};\nRule.FAILURE = 'Warning: impure pipe declared in class %s.';\nexports.Rule = Rule;\nvar ClassMetadataWalker = (function (_super) {\n    __extends(ClassMetadataWalker, _super);\n    function ClassMetadataWalker(sourceFile, rule) {\n        var _this = _super.call(this, sourceFile, rule.getOptions()) || this;\n        _this.rule = rule;\n        return _this;\n    }\n    ClassMetadataWalker.prototype.visitNg2Pipe = function (controller, decorator) {\n        this.validateProperties(controller.name.text, decorator);\n    };\n    ClassMetadataWalker.prototype.validateProperties = function (className, pipe) {\n        var argument = this.extractArgument(pipe);\n        if (argument.kind === SyntaxKind.current().ObjectLiteralExpression) {\n            argument.properties.filter(function (n) { return n.name.text === 'pure'; })\n                .forEach(this.validateProperty.bind(this, className));\n        }\n    };\n    ClassMetadataWalker.prototype.extractArgument = function (pipe) {\n        var baseExpr = pipe.expression || {};\n        var args = baseExpr.arguments || [];\n        return args[0];\n    };\n    ClassMetadataWalker.prototype.validateProperty = function (className, property) {\n        var propValue = property.initializer.getText();\n        if (propValue === 'false') {\n            this.addFailure(this.createFailure(property.getStart(), property.getWidth(), sprintf_js_1.sprintf.apply(this, this.createFailureArray(className))));\n        }\n    };\n    ClassMetadataWalker.prototype.createFailureArray = function (className) {\n        return [Rule.FAILURE, className];\n    };\n    return ClassMetadataWalker;\n}(ng2Walker_1.Ng2Walker));\nexports.ClassMetadataWalker = ClassMetadataWalker;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/pipeNamingRule.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Lint = require(\"tslint\");\nvar sprintf_js_1 = require(\"sprintf-js\");\nvar SyntaxKind = require(\"./util/syntaxKind\");\nvar ng2Walker_1 = require(\"./angular/ng2Walker\");\nvar selectorValidator_1 = require(\"./util/selectorValidator\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule(ruleName, value, disabledIntervals) {\n        var _this = _super.call(this, ruleName, value, disabledIntervals) || this;\n        if (value[1] === 'camelCase') {\n            _this.validator = selectorValidator_1.SelectorValidator.camelCase;\n        }\n        if (value.length > 2) {\n            _this.hasPrefix = true;\n            var prefixExpression = (value.slice(2) || []).join('|');\n            _this.prefix = (value.slice(2) || []).join(',');\n            _this.prefixChecker = selectorValidator_1.SelectorValidator.prefix(prefixExpression, 'camelCase');\n        }\n        return _this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new ClassMetadataWalker(sourceFile, this));\n    };\n    Rule.prototype.validateName = function (name) {\n        return this.validator(name);\n    };\n    Rule.prototype.validatePrefix = function (prefix) {\n        return this.prefixChecker(prefix);\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nRule.metadata = {\n    ruleName: 'pipe-naming-rule',\n    type: 'style',\n    description: \"Enforce consistent case and prefix for pipes.\",\n    rationale: \"Consistent conventions make it easy to quickly identify and reference assets of different types.\",\n    options: {\n        'type': 'array',\n        'items': [\n            { 'enum': ['kebab-case', 'attribute'] },\n            { 'type': 'string' }\n        ],\n        'minItems': 1\n    },\n    optionExamples: [\n        \"[\\\"camelCase\\\", \\\"myPrefix\\\"]\",\n        \"[\\\"camelCase\\\", \\\"myPrefix\\\", \\\"myOtherPrefix\\\"]\",\n        \"[\\\"kebab-case\\\", \\\"my-prefix\\\"]\",\n    ],\n    optionsDescription: (_a = [\"\\n    * The first item in the array is `\\\"kebab-case\\\"` or `\\\"camelCase\\\"`, which allows you to pick a case.\\n    * The rest of the arguments are supported prefixes (given as strings). They are optional.\"], _a.raw = [\"\\n    * The first item in the array is \\\\`\\\"kebab-case\\\"\\\\` or \\\\`\\\"camelCase\\\"\\\\`, which allows you to pick a case.\\n    * The rest of the arguments are supported prefixes (given as strings). They are optional.\"], Lint.Utils.dedent(_a)),\n    typescriptOnly: true,\n};\nRule.FAILURE_WITHOUT_PREFIX = 'The name of the Pipe decorator of class %s should' +\n    ' be named camelCase, however its value is \"%s\".';\nRule.FAILURE_WITH_PREFIX = 'The name of the Pipe decorator of class %s should' +\n    ' be named camelCase with prefix %s, however its value is \"%s\".';\nexports.Rule = Rule;\nvar ClassMetadataWalker = (function (_super) {\n    __extends(ClassMetadataWalker, _super);\n    function ClassMetadataWalker(sourceFile, rule) {\n        var _this = _super.call(this, sourceFile, rule.getOptions()) || this;\n        _this.rule = rule;\n        return _this;\n    }\n    ClassMetadataWalker.prototype.visitNg2Pipe = function (controller, decorator) {\n        var className = controller.name.text;\n        this.validateProperties(className, decorator);\n    };\n    ClassMetadataWalker.prototype.validateProperties = function (className, pipe) {\n        var argument = this.extractArgument(pipe);\n        if (argument.kind === SyntaxKind.current().ObjectLiteralExpression) {\n            argument.properties.filter(function (n) { return n.name.text === 'name'; })\n                .forEach(this.validateProperty.bind(this, className));\n        }\n    };\n    ClassMetadataWalker.prototype.extractArgument = function (pipe) {\n        var baseExpr = pipe.expression || {};\n        var args = baseExpr.arguments || [];\n        return args[0];\n    };\n    ClassMetadataWalker.prototype.validateProperty = function (className, property) {\n        var propName = property.initializer.text;\n        var isValidName = this.rule.validateName(propName);\n        var isValidPrefix = (this.rule.hasPrefix ? this.rule.validatePrefix(propName) : true);\n        if (!isValidName || !isValidPrefix) {\n            this.addFailure(this.createFailure(property.getStart(), property.getWidth(), sprintf_js_1.sprintf.apply(this, this.createFailureArray(className, propName))));\n        }\n    };\n    ClassMetadataWalker.prototype.createFailureArray = function (className, pipeName) {\n        if (this.rule.hasPrefix) {\n            return [Rule.FAILURE_WITH_PREFIX, className, this.rule.prefix, pipeName];\n        }\n        return [Rule.FAILURE_WITHOUT_PREFIX, className, pipeName];\n    };\n    return ClassMetadataWalker;\n}(ng2Walker_1.Ng2Walker));\nexports.ClassMetadataWalker = ClassMetadataWalker;\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/propertyDecoratorBase.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Lint = require(\"tslint\");\nvar ts = require(\"typescript\");\nvar sprintf_js_1 = require(\"sprintf-js\");\nvar SyntaxKind = require(\"./util/syntaxKind\");\nvar UsePropertyDecorator = (function (_super) {\n    __extends(UsePropertyDecorator, _super);\n    function UsePropertyDecorator(config, ruleName, value, disabledIntervals) {\n        var _this = _super.call(this, ruleName, value, disabledIntervals) || this;\n        _this.config = config;\n        return _this;\n    }\n    UsePropertyDecorator.formatFailureString = function (config, decoratorName, className) {\n        var decorators = config.decoratorName;\n        if (decorators instanceof Array) {\n            decorators = decorators.map(function (d) { return \"\\\"@\" + d + \"\\\"\"; }).join(', ');\n        }\n        else {\n            decorators = \"\\\"@\" + decorators + \"\\\"\";\n        }\n        return sprintf_js_1.sprintf(config.errorMessage, decoratorName, className, config.propertyName, decorators);\n    };\n    UsePropertyDecorator.prototype.apply = function (sourceFile) {\n        var documentRegistry = ts.createDocumentRegistry();\n        var languageServiceHost = Lint.createLanguageServiceHost('file.ts', sourceFile.getFullText());\n        return this.applyWithWalker(new DirectiveMetadataWalker(sourceFile, this.getOptions(), ts.createLanguageService(languageServiceHost, documentRegistry), this.config));\n    };\n    return UsePropertyDecorator;\n}(Lint.Rules.AbstractRule));\nexports.UsePropertyDecorator = UsePropertyDecorator;\nvar DirectiveMetadataWalker = (function (_super) {\n    __extends(DirectiveMetadataWalker, _super);\n    function DirectiveMetadataWalker(sourceFile, options, languageService, config) {\n        var _this = _super.call(this, sourceFile, options) || this;\n        _this.config = config;\n        _this.languageService = languageService;\n        _this.typeChecker = languageService.getProgram().getTypeChecker();\n        return _this;\n    }\n    DirectiveMetadataWalker.prototype.visitClassDeclaration = function (node) {\n        (node.decorators || [])\n            .forEach(this.validateDecorator.bind(this, node.name.text));\n        _super.prototype.visitClassDeclaration.call(this, node);\n    };\n    DirectiveMetadataWalker.prototype.validateDecorator = function (className, decorator) {\n        var baseExpr = decorator.expression || {};\n        var expr = baseExpr.expression || {};\n        var name = expr.text;\n        var args = baseExpr.arguments || [];\n        var arg = args[0];\n        if (/^(Component|Directive)$/.test(name) && arg) {\n            this.validateProperty(className, name, arg);\n        }\n    };\n    DirectiveMetadataWalker.prototype.validateProperty = function (className, decoratorName, arg) {\n        var _this = this;\n        if (arg.kind === SyntaxKind.current().ObjectLiteralExpression) {\n            arg\n                .properties\n                .filter(function (prop) { return prop.name.text === _this.config.propertyName; })\n                .forEach(function (prop) {\n                var p = prop;\n                _this.addFailure(_this.createFailure(p.getStart(), p.getWidth(), UsePropertyDecorator.formatFailureString(_this.config, decoratorName, className)));\n            });\n        }\n    };\n    return DirectiveMetadataWalker;\n}(Lint.RuleWalker));\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/templatesUsePublicRule.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Lint = require(\"tslint\");\nvar utils_1 = require(\"./util/utils\");\nvar classDeclarationUtils_1 = require(\"./util/classDeclarationUtils\");\nvar ng2Walker_1 = require(\"./angular/ng2Walker\");\nvar recursiveAngularExpressionVisitor_1 = require(\"./angular/templates/recursiveAngularExpressionVisitor\");\nvar SyntaxKind = require(\"./util/syntaxKind\");\nvar DeclarationType;\n(function (DeclarationType) {\n    DeclarationType[DeclarationType[\"Property\"] = 0] = \"Property\";\n    DeclarationType[DeclarationType[\"Method\"] = 1] = \"Method\";\n})(DeclarationType || (DeclarationType = {}));\n;\nvar SymbolAccessValidator = (function (_super) {\n    __extends(SymbolAccessValidator, _super);\n    function SymbolAccessValidator() {\n        return _super.apply(this, arguments) || this;\n    }\n    SymbolAccessValidator.prototype.visitPropertyRead = function (ast, context) {\n        return this.doCheck(ast, DeclarationType.Property, context);\n    };\n    SymbolAccessValidator.prototype.visitMethodCall = function (ast, context) {\n        this.doCheck(ast, DeclarationType.Method, context);\n    };\n    SymbolAccessValidator.prototype.visitPropertyWrite = function (ast, context) {\n        this.doCheck(ast, DeclarationType.Property, context);\n    };\n    SymbolAccessValidator.prototype.doCheck = function (ast, type, context) {\n        if (ast.receiver && (ast.receiver.name || ast.receiver.key)) {\n            var receiver = ast.receiver;\n            while (receiver.receiver.name) {\n                receiver = receiver.receiver;\n            }\n            ast = receiver;\n        }\n        var allMembers = classDeclarationUtils_1.getDeclaredMethods(this.context.controller).concat(classDeclarationUtils_1.getDeclaredProperties(this.context.controller));\n        var member = allMembers.filter(function (m) { return m.name && m.name.text === ast.name; }).pop();\n        if (member) {\n            var isPublic = !member.modifiers || !member.modifiers\n                .some(function (m) { return m.kind === SyntaxKind.current().PrivateKeyword || m.kind === SyntaxKind.current().ProtectedKeyword; });\n            var width = ast.name.length;\n            if (!isPublic) {\n                var failureString = \"You can bind only to public class members. \\\"\" + member.name.getText() + \"\\\" is not a public class member.\";\n                this.addFailure(this.createFailure(ast.span.start, width, failureString));\n            }\n        }\n    };\n    SymbolAccessValidator.prototype.getTopSuggestion = function (list, current) {\n        var result = [];\n        var tmp = list.map(function (e) {\n            return {\n                element: e,\n                distance: utils_1.stringDistance(e, current)\n            };\n        }).sort(function (a, b) { return a.distance - b.distance; });\n        var first = tmp.shift();\n        if (!first) {\n            return [];\n        }\n        else {\n            result.push(first);\n            var current_1;\n            while (current_1 = tmp.shift()) {\n                if (current_1.distance !== first.distance) {\n                    return result;\n                }\n                else {\n                    result.push(current_1);\n                }\n            }\n            return result;\n        }\n    };\n    return SymbolAccessValidator;\n}(recursiveAngularExpressionVisitor_1.RecursiveAngularExpressionVisitor));\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new ng2Walker_1.Ng2Walker(sourceFile, this.getOptions(), {\n            expressionVisitorCtrl: SymbolAccessValidator\n        }));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nRule.metadata = {\n    ruleName: 'templates-use-public-rule',\n    type: 'functionality',\n    description: \"Ensure that properties and methods accessed from the template are public.\",\n    rationale: \"When Angular compiles the templates, it has to access these propertes from outside the class.\",\n    options: null,\n    optionsDescription: \"Not configurable.\",\n    typescriptOnly: true,\n};\nRule.FAILURE = 'The %s \"%s\" that you\\'re trying to access does not exist in the class declaration.';\nexports.Rule = Rule;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/util/classDeclarationUtils.js":"\"use strict\";\nvar syntaxKind_1 = require(\"./syntaxKind\");\nvar SyntaxKind = syntaxKind_1.current();\nexports.getDeclaredProperties = function (declaration) {\n    var m = declaration.members;\n    var ctr = m.filter(function (m) { return m.kind === SyntaxKind.Constructor; }).pop();\n    var params = [];\n    if (ctr) {\n        params = (ctr.parameters || [])\n            .filter(function (p) { return p.kind === SyntaxKind.Parameter; });\n    }\n    return m.filter(function (m) { return m.kind === SyntaxKind.PropertyDeclaration ||\n        m.kind === SyntaxKind.GetAccessor || m.kind === SyntaxKind.SetAccessor; }).concat(params);\n};\nexports.getDeclaredPropertyNames = function (declaration) {\n    return exports.getDeclaredProperties(declaration).filter(function (p) { return p && p.name; }).map(function (p) { return p.name.text; });\n};\nexports.getDeclaredMethods = function (declaration) {\n    return declaration.members.filter(function (m) { return m.kind === SyntaxKind.MethodDeclaration; });\n};\nexports.getDeclaredMethodNames = function (declaration) {\n    return exports.getDeclaredMethods(declaration)\n        .map(function (d) { return d.name.text; });\n};\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/templateToNgTemplateRule.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Lint = require(\"tslint\");\nvar ng2Walker_1 = require(\"./angular/ng2Walker\");\nvar basicTemplateAstVisitor_1 = require(\"./angular/templates/basicTemplateAstVisitor\");\nvar ErrorMessage = 'You should use <ng-template/> instead of <template/>';\nvar TemplateStart = '<template';\nvar TemplateEnd = '</template>';\nvar TemplateEndRe = /<\\/template>/i;\nvar set = new Set();\nvar TemplateToNgTemplateVisitor = (function (_super) {\n    __extends(TemplateToNgTemplateVisitor, _super);\n    function TemplateToNgTemplateVisitor() {\n        var _this = _super.apply(this, arguments) || this;\n        _this._prevClosing = 0;\n        _this._visitedElements = new Set();\n        return _this;\n    }\n    TemplateToNgTemplateVisitor.prototype.visitEmbeddedTemplate = function (element, ctx) {\n        if (this._visitedElements.has(element)) {\n            return;\n        }\n        else {\n            this._visitedElements.add(element);\n        }\n        var sp = element.sourceSpan;\n        var content = sp.start.file.content;\n        var subtemplate = content.substring(sp.start.offset, sp.end.offset);\n        if (subtemplate.startsWith(TemplateStart)) {\n            var replacement = this.createReplacement(sp.start.offset, TemplateStart.length, '<ng-template');\n            if (!this._fix) {\n                this._fix = this.createFix(replacement);\n            }\n            else {\n                this._fix.replacements.push(replacement);\n            }\n            this.addFailure(this.createFailure(sp.start.offset, sp.end.offset - sp.start.offset, ErrorMessage));\n        }\n        _super.prototype.visitEmbeddedTemplate.call(this, element, ctx);\n        var subcontent = content.substring(this._prevClosing, content.length);\n        var matches = TemplateEndRe.exec(subcontent);\n        if (this._fix && matches && typeof matches.index === 'number') {\n            this._fix.replacements.push(this.createReplacement(matches.index + this._prevClosing, TemplateEnd.length, '</ng-template>'));\n            this._prevClosing = matches.index + this._prevClosing + TemplateEnd.length;\n            var rest = content.substring(this._prevClosing, content.length);\n            if (!TemplateEndRe.test(rest)) {\n                this._fix = null;\n                this._prevClosing = 0;\n                this._visitedElements = new Set();\n            }\n        }\n    };\n    return TemplateToNgTemplateVisitor;\n}(basicTemplateAstVisitor_1.BasicTemplateAstVisitor));\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new ng2Walker_1.Ng2Walker(sourceFile, this.getOptions(), {\n            templateVisitorCtrl: TemplateToNgTemplateVisitor\n        }));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nRule.metadata = {\n    ruleName: 'templates-use-public-rule',\n    type: 'functionality',\n    description: \"Ensure that properties and methods accessed from the template are public.\",\n    rationale: \"When Angular compiles the templates, it has to access these propertes from outside the class.\",\n    options: null,\n    optionsDescription: \"Not configurable.\",\n    typescriptOnly: true,\n};\nRule.FAILURE = 'The %s \"%s\" that you\\'re trying to access does not exist in the class declaration.';\nexports.Rule = Rule;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/useHostPropertyDecoratorRule.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar propertyDecoratorBase_1 = require(\"./propertyDecoratorBase\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule(ruleName, value, disabledIntervals) {\n        return _super.call(this, {\n            decoratorName: ['HostBindings', 'HostListeners'],\n            propertyName: 'host',\n            errorMessage: 'Use @HostBindings and @HostListeners instead of the host property (https://goo.gl/zrdmKr)'\n        }, ruleName, value, disabledIntervals) || this;\n    }\n    return Rule;\n}(propertyDecoratorBase_1.UsePropertyDecorator));\nRule.metadata = {\n    ruleName: 'use-host-property-decorator-rule',\n    type: 'style',\n    description: \"Use @HostProperty decorator rather than the `host` property of `@Component` and `@Directive` metadata.\",\n    descriptionDetails: \"See more at https://angular.io/styleguide#!#06-03.\",\n    rationale: \"The property associated with `@HostBinding` or the method associated with `@HostListener` \" +\n        \"can be modified only in a single place: in the directive's class. If you use the `host` metadata \" +\n        \"property, you must modify both the property declaration inside the controller, and the metadata \" +\n        \"associated with the directive.\",\n    options: null,\n    optionsDescription: \"Not configurable.\",\n    typescriptOnly: true,\n};\nexports.Rule = Rule;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/useInputPropertyDecoratorRule.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Lint = require(\"tslint\");\nvar propertyDecoratorBase_1 = require(\"./propertyDecoratorBase\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule(ruleName, value, disabledIntervals) {\n        return _super.call(this, {\n            decoratorName: 'Input',\n            propertyName: 'inputs',\n            errorMessage: 'Use the @Input property decorator instead of the inputs property (https://goo.gl/U0lrdN)'\n        }, ruleName, value, disabledIntervals) || this;\n    }\n    return Rule;\n}(propertyDecoratorBase_1.UsePropertyDecorator));\nRule.metadata = {\n    ruleName: 'use-input-property-decorator-rule',\n    type: 'style',\n    description: \"Use `@Input` decorator rather than the `inputs` property of `@Component` and `@Directive` metadata.\",\n    descriptionDetails: \"See more at https://angular.io/styleguide#!#05-12.\",\n    rationale: (_a = [\"\\n    * It is easier and more readable to identify which properties in a class are inputs.\\n    * If you ever need to rename the property name associated with `@Input`, you can modify it in a single place.\\n    * The metadata declaration attached to the directive is shorter and thus more readable.\\n    * Placing the decorator on the same line usually makes for shorter code and still easily identifies the property as an input.\"], _a.raw = [\"\\n    * It is easier and more readable to identify which properties in a class are inputs.\\n    * If you ever need to rename the property name associated with \\\\`@Input\\\\`, you can modify it in a single place.\\n    * The metadata declaration attached to the directive is shorter and thus more readable.\\n    * Placing the decorator on the same line usually makes for shorter code and still easily identifies the property as an input.\"], Lint.Utils.dedent(_a)),\n    options: null,\n    optionsDescription: \"Not configurable.\",\n    typescriptOnly: true,\n};\nexports.Rule = Rule;\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/useLifeCycleInterfaceRule.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Lint = require(\"tslint\");\nvar sprintf_js_1 = require(\"sprintf-js\");\nvar SyntaxKind = require(\"./util/syntaxKind\");\nvar getInterfaceName = function (t) {\n    if (t.expression && t.expression.name) {\n        return t.expression.name.text;\n    }\n    return t.expression.text;\n};\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new ClassMetadataWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nRule.metadata = {\n    ruleName: 'use-life-cycle-interface',\n    type: 'maintainability',\n    description: \"Ensure that components implement life cycle interfaces if they use them.\",\n    descriptionDetails: \"See more at https://angular.io/styleguide#!#09-01.\",\n    rationale: \"Interfaces prescribe typed method signatures. Use those signatures to flag spelling and syntax mistakes.\",\n    options: null,\n    optionsDescription: \"Not configurable.\",\n    typescriptOnly: true,\n};\nRule.FAILURE = 'Implement lifecycle hook interface %s for method %s in class %s (https://goo.gl/w1Nwk3)';\nRule.HOOKS_PREFIX = 'ng';\nRule.LIFE_CYCLE_HOOKS_NAMES = [\n    'OnChanges',\n    'OnInit',\n    'DoCheck',\n    'AfterContentInit',\n    'AfterContentChecked',\n    'AfterViewInit',\n    'AfterViewChecked',\n    'OnDestroy'\n];\nexports.Rule = Rule;\nvar ClassMetadataWalker = (function (_super) {\n    __extends(ClassMetadataWalker, _super);\n    function ClassMetadataWalker() {\n        return _super.apply(this, arguments) || this;\n    }\n    ClassMetadataWalker.prototype.visitClassDeclaration = function (node) {\n        var syntaxKind = SyntaxKind.current();\n        var className = node.name.text;\n        var interfaces = this.extractInterfaces(node, syntaxKind);\n        var methods = node.members.filter(function (m) { return m.kind === syntaxKind.MethodDeclaration; });\n        this.validateMethods(methods, interfaces, className);\n        _super.prototype.visitClassDeclaration.call(this, node);\n    };\n    ClassMetadataWalker.prototype.extractInterfaces = function (node, syntaxKind) {\n        var interfaces = [];\n        if (node.heritageClauses) {\n            var interfacesClause = node.heritageClauses.filter(function (h) { return h.token === syntaxKind.ImplementsKeyword; });\n            if (interfacesClause.length !== 0) {\n                interfaces = interfacesClause[0].types.map(getInterfaceName);\n            }\n        }\n        return interfaces;\n    };\n    ClassMetadataWalker.prototype.validateMethods = function (methods, interfaces, className) {\n        var _this = this;\n        methods.forEach(function (m) {\n            var n = m.name.text;\n            if (n && _this.isMethodValidHook(m, interfaces)) {\n                var hookName = n.substr(2, n.lenght);\n                _this.addFailure(_this.createFailure(m.name.getStart(), m.name.getWidth(), sprintf_js_1.sprintf.apply(_this, [Rule.FAILURE, hookName, Rule.HOOKS_PREFIX + hookName, className])));\n            }\n        });\n    };\n    ClassMetadataWalker.prototype.isMethodValidHook = function (m, interfaces) {\n        var n = m.name.text;\n        var isNg = n.substr(0, 2) === Rule.HOOKS_PREFIX;\n        var hookName = n.substr(2, n.lenght);\n        var isHook = Rule.LIFE_CYCLE_HOOKS_NAMES.indexOf(hookName) !== -1;\n        var isNotIn = interfaces.indexOf(hookName) === -1;\n        return isNg && isHook && isNotIn;\n    };\n    return ClassMetadataWalker;\n}(Lint.RuleWalker));\nexports.ClassMetadataWalker = ClassMetadataWalker;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/useOutputPropertyDecoratorRule.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Lint = require(\"tslint\");\nvar propertyDecoratorBase_1 = require(\"./propertyDecoratorBase\");\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule(ruleName, value, disabledIntervals) {\n        return _super.call(this, {\n            decoratorName: 'Output',\n            propertyName: 'outputs',\n            errorMessage: 'Use the @Output property decorator instead of the outputs property (https://goo.gl/U0lrdN)'\n        }, ruleName, value, disabledIntervals) || this;\n    }\n    return Rule;\n}(propertyDecoratorBase_1.UsePropertyDecorator));\nRule.metadata = {\n    ruleName: 'use-output-property-decorator-rule',\n    type: 'style',\n    description: \"Use `@Output` decorator rather than the `outputs` property of `@Component` and `@Directive` metadata.\",\n    descriptionDetails: \"See more at https://angular.io/styleguide#!#05-12.\",\n    rationale: (_a = [\"\\n    * It is easier and more readable to identify which properties in a class are events.\\n    * If you ever need to rename the event name associated with `@Output`, you can modify it in a single place.\\n    * The metadata declaration attached to the directive is shorter and thus more readable.\\n    * Placing the decorator on the same line usually makes for shorter code and still easily identifies the property as an output.\"], _a.raw = [\"\\n    * It is easier and more readable to identify which properties in a class are events.\\n    * If you ever need to rename the event name associated with \\\\`@Output\\\\`, you can modify it in a single place.\\n    * The metadata declaration attached to the directive is shorter and thus more readable.\\n    * Placing the decorator on the same line usually makes for shorter code and still easily identifies the property as an output.\"], Lint.Utils.dedent(_a)),\n    options: null,\n    optionsDescription: \"Not configurable.\",\n    typescriptOnly: true,\n};\nexports.Rule = Rule;\nvar _a;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/usePipeTransformInterfaceRule.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Lint = require(\"tslint\");\nvar sprintf_js_1 = require(\"sprintf-js\");\nvar SyntaxKind = require(\"./util/syntaxKind\");\nvar getInterfaceName = function (t) {\n    if (t.expression && t.expression.name) {\n        return t.expression.name.text;\n    }\n    return t.expression.text;\n};\nvar Rule = (function (_super) {\n    __extends(Rule, _super);\n    function Rule() {\n        return _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new ClassMetadataWalker(sourceFile, this.getOptions()));\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nRule.metadata = {\n    ruleName: 'use-pipe-transform-interface',\n    type: 'maintainability',\n    description: \"Ensure that pipes implement PipeTransform interface.\",\n    rationale: \"Interfaces prescribe typed method signatures. Use those signatures to flag spelling and syntax mistakes.\",\n    options: null,\n    optionsDescription: \"Not configurable.\",\n    typescriptOnly: true,\n};\nRule.FAILURE = 'The %s class has the Pipe decorator, so it should implement the PipeTransform interface';\nRule.PIPE_INTERFACE_NAME = 'PipeTransform';\nexports.Rule = Rule;\nvar ClassMetadataWalker = (function (_super) {\n    __extends(ClassMetadataWalker, _super);\n    function ClassMetadataWalker() {\n        return _super.apply(this, arguments) || this;\n    }\n    ClassMetadataWalker.prototype.visitClassDeclaration = function (node) {\n        var decorators = node.decorators;\n        if (decorators) {\n            var pipes = decorators.map(function (d) {\n                return d.expression.text ||\n                    (d.expression.expression || {}).text;\n            }).filter(function (t) { return t === 'Pipe'; });\n            if (pipes.length !== 0) {\n                var className = node.name.text;\n                if (!this.hasIPipeTransform(node)) {\n                    this.addFailure(this.createFailure(node.getStart(), node.getWidth(), sprintf_js_1.sprintf.apply(this, [Rule.FAILURE, className])));\n                }\n            }\n        }\n        _super.prototype.visitClassDeclaration.call(this, node);\n    };\n    ClassMetadataWalker.prototype.hasIPipeTransform = function (node) {\n        var interfaces = [];\n        if (node.heritageClauses) {\n            var interfacesClause = node.heritageClauses\n                .filter(function (h) { return h.token === SyntaxKind.current().ImplementsKeyword; });\n            if (interfacesClause.length !== 0) {\n                interfaces = interfacesClause[0].types.map(getInterfaceName);\n            }\n        }\n        return interfaces.indexOf(Rule.PIPE_INTERFACE_NAME) !== -1;\n    };\n    return ClassMetadataWalker;\n}(Lint.RuleWalker));\nexports.ClassMetadataWalker = ClassMetadataWalker;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/angular/config.js":"\"use strict\";\nexports.LogLevel = {\n    None: 0,\n    Error: 1,\n    Info: 3,\n    Debug: 7\n};\nvar BUILD_TYPE = 'prod';\nexports.Config = {\n    interpolation: ['{{', '}}'],\n    resolveUrl: function (url, d) {\n        return url;\n    },\n    transformTemplate: function (code, url, d) {\n        if (!url || url.endsWith('.html')) {\n            return { code: code, url: url };\n        }\n        return { code: '', url: url };\n    },\n    transformStyle: function (code, url, d) {\n        if (!url || url.endsWith('.css')) {\n            return { code: code, url: url };\n        }\n        return { code: '', url: url };\n    },\n    predefinedDirectives: [\n        { selector: 'form', exportAs: 'ngForm' },\n        { selector: '[routerLinkActive]', exportAs: 'routerLinkActive' },\n        { selector: '[ngModel]:not([formControlName]):not([formControl])', exportAs: 'ngModel' },\n        { selector: '[md-menu-item], [mat-menu-item]', exportAs: 'mdMenuItem' },\n        { selector: 'md-menu, mat-menu', exportAs: 'mdMenu' },\n        { selector: 'md-button-toggle-group:not([multiple])', exportAs: 'mdButtonToggleGroup' },\n        { selector: '[md-menu-trigger-for], [mat-menu-trigger-for], [mdMenuTriggerFor]', exportAs: 'mdMenuTrigger' },\n        { selector: '[md-tooltip], [mat-tooltip], [mdTooltip]', exportAs: 'mdTooltip' },\n        { selector: 'md-select, mat-select', exportAs: 'mdSelect' },\n        { selector: '[ngIf]', exportAs: 'ngIf', inputs: ['ngIf'] },\n        { selector: '[ngSwitch]', exportAs: 'ngSwitch', inputs: ['ngSwitch'] }\n    ],\n    logLevel: BUILD_TYPE === 'dev' ? exports.LogLevel.Debug : exports.LogLevel.None\n};\ntry {\n    var root = require('app-root-path');\n    var newConfig = require(root.path + '/.codelyzer');\n    Object.assign(exports.Config, newConfig);\n}\ncatch (e) { }\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/angular/expressionTypes.js":"\"use strict\";\nexports.ExpTypes = {\n    Binary: function (ast) {\n        return ast.constructor.name === 'Binary';\n    },\n    Quote: function (ast) {\n        return ast.constructor.name === 'Quote';\n    },\n    EmptyExpr: function (ast) {\n        return ast.constructor.name === 'EmptyExpr';\n    },\n    ImplicitReceiver: function (ast) {\n        return ast.constructor.name === 'ImplicitReceiver';\n    },\n    Chain: function (ast) {\n        return ast.constructor.name === 'Chain';\n    },\n    Conditional: function (ast) {\n        return ast.constructor.name === 'Conditional';\n    },\n    PropertyRead: function (ast) {\n        return ast.constructor.name === 'PropertyRead';\n    },\n    PropertyWrite: function (ast) {\n        return ast.constructor.name === 'PropertyWrite';\n    },\n    SafePropertyRead: function (ast) {\n        return ast.constructor.name === 'SafePropertyRead';\n    },\n    KeyedRead: function (ast) {\n        return ast.constructor.name === 'KeyedRead';\n    },\n    KeyedWrite: function (ast) {\n        return ast.constructor.name === 'KeyedWrite';\n    },\n    BindingPipe: function (ast) {\n        return ast.constructor.name === 'BindingPipe';\n    },\n    LiteralPrimitive: function (ast) {\n        return ast.constructor.name === 'LiteralPrimitive';\n    },\n    LiteralArray: function (ast) {\n        return ast.constructor.name === 'LiteralArray';\n    },\n    LiteralMap: function (ast) {\n        return ast.constructor.name === 'LiteralMap';\n    },\n    Interpolation: function (ast) {\n        return ast.constructor.name === 'Interpolation';\n    },\n    PrefixNot: function (ast) {\n        return ast.constructor.name === 'PrefixNot';\n    },\n    MethodCall: function (ast) {\n        return ast.constructor.name === 'MethodCall';\n    },\n    SafeMethodCall: function (ast) {\n        return ast.constructor.name === 'SafeMethodCall';\n    },\n    FunctionCall: function (ast) {\n        return ast.constructor.name === 'FunctionCall';\n    },\n    ASTWithSource: function (ast) {\n        return ast.constructor.name === 'ASTWithSource';\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/angular/metadata.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DirectiveMetadata = (function () {\n    function DirectiveMetadata() {\n    }\n    return DirectiveMetadata;\n}());\nexports.DirectiveMetadata = DirectiveMetadata;\nvar ComponentMetadata = (function (_super) {\n    __extends(ComponentMetadata, _super);\n    function ComponentMetadata() {\n        return _super.apply(this, arguments) || this;\n    }\n    return ComponentMetadata;\n}(DirectiveMetadata));\nexports.ComponentMetadata = ComponentMetadata;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/angular/metadataReader.js":"\"use strict\";\nvar urlResolver_1 = require(\"./urlResolvers/urlResolver\");\nvar pathResolver_1 = require(\"./urlResolvers/pathResolver\");\nvar logger_1 = require(\"../util/logger\");\nvar config_1 = require(\"./config\");\nvar metadata_1 = require(\"./metadata\");\nvar function_1 = require(\"../util/function\");\nvar astQuery_1 = require(\"../util/astQuery\");\nvar ngQuery_1 = require(\"../util/ngQuery\");\nvar normalizeTransformed = function (t) {\n    if (!t.map) {\n        t.source = t.code;\n    }\n    return t;\n};\nvar MetadataReader = (function () {\n    function MetadataReader(_fileResolver, _urlResolver) {\n        this._fileResolver = _fileResolver;\n        this._urlResolver = _urlResolver;\n        this._urlResolver = this._urlResolver || new urlResolver_1.UrlResolver(new pathResolver_1.PathResolver());\n    }\n    MetadataReader.prototype.read = function (d) {\n        var _this = this;\n        var componentMetadata = function_1.unwrapFirst((d.decorators || []).map(function (dec) {\n            return function_1.Maybe.lift(dec).bind(astQuery_1.callExpression)\n                .bind(astQuery_1.withIdentifier('Component'))\n                .fmap(function () { return _this.readComponentMetadata(d, dec); });\n        }));\n        var directiveMetadata = function_1.unwrapFirst((d.decorators || []).map(function (dec) {\n            return function_1.Maybe.lift(dec)\n                .bind(astQuery_1.callExpression)\n                .bind(astQuery_1.withIdentifier('Directive'))\n                .fmap(function () { return _this.readDirectiveMetadata(d, dec); });\n        }));\n        return directiveMetadata || componentMetadata || undefined;\n    };\n    MetadataReader.prototype.readDirectiveMetadata = function (d, dec) {\n        var selector = this.getDecoratorArgument(dec)\n            .bind(function (expr) { return astQuery_1.getStringInitializerFromProperty('selector', expr.properties); })\n            .fmap(function (initializer) { return initializer.text; });\n        return Object.assign(new metadata_1.DirectiveMetadata(), {\n            controller: d,\n            decorator: dec,\n            selector: selector.unwrap(),\n        });\n    };\n    MetadataReader.prototype.readComponentMetadata = function (d, dec) {\n        var _this = this;\n        var expr = this.getDecoratorArgument(dec);\n        var directiveMetadata = this.readDirectiveMetadata(d, dec);\n        var external_M = expr.fmap(function () { return _this._urlResolver.resolve(dec); });\n        var template_M = external_M.bind(function (external) {\n            return _this.readComponentTemplateMetadata(dec, external);\n        });\n        var style_M = external_M.bind(function (external) {\n            return _this.readComponentStylesMetadata(dec, external);\n        });\n        return Object.assign(new metadata_1.ComponentMetadata(), directiveMetadata, {\n            template: template_M.unwrap(),\n            styles: style_M.unwrap(),\n        });\n    };\n    MetadataReader.prototype.getDecoratorArgument = function (decorator) {\n        return astQuery_1.decoratorArgument(decorator)\n            .bind(function_1.ifTrue(astQuery_1.hasProperties));\n    };\n    MetadataReader.prototype.readComponentTemplateMetadata = function (dec, external) {\n        var _this = this;\n        return ngQuery_1.getTemplate(dec)\n            .fmap(function (inlineTemplate) { return ({\n            template: normalizeTransformed(config_1.Config.transformTemplate(inlineTemplate.text, null, dec)),\n            url: null,\n            node: inlineTemplate,\n        }); }).catch(function () {\n            return function_1.Maybe.lift(external.templateUrl)\n                .bind(function (url) {\n                return _this._resolve(url).fmap(function (template) { return ({\n                    template: normalizeTransformed(config_1.Config.transformTemplate(template, url, dec)),\n                    url: url,\n                    node: null\n                }); });\n            });\n        });\n    };\n    MetadataReader.prototype.readComponentStylesMetadata = function (dec, external) {\n        var _this = this;\n        return ngQuery_1.getInlineStyle(dec).fmap(function (inlineStyles) {\n            return inlineStyles.elements.map(function (inlineStyle) {\n                if (astQuery_1.isSimpleTemplateString(inlineStyle)) {\n                    return {\n                        style: normalizeTransformed(config_1.Config.transformStyle(inlineStyle.text, null, dec)),\n                        url: null,\n                        node: inlineStyle,\n                    };\n                }\n            }).filter(function (v) { return !!v; });\n        }).catch(function () {\n            return function_1.Maybe.lift(external.styleUrls)\n                .fmap(function (urls) { return urls.map(function (url) {\n                return _this._resolve(url).fmap(function (style) { return ({\n                    style: normalizeTransformed(config_1.Config.transformStyle(style, url, dec)),\n                    url: url,\n                    node: null,\n                }); });\n            }); })\n                .bind(function (url_Ms) { return function_1.listToMaybe(url_Ms); });\n        });\n    };\n    MetadataReader.prototype._resolve = function (url) {\n        try {\n            return function_1.Maybe.lift(this._fileResolver.resolve(url));\n        }\n        catch (e) {\n            logger_1.logger.info('Cannot read file' + url);\n            return function_1.Maybe.nothing;\n        }\n    };\n    return MetadataReader;\n}());\nexports.MetadataReader = MetadataReader;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/angular/urlResolvers/urlResolver.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar config_1 = require(\"../config\");\nvar abstractResolver_1 = require(\"./abstractResolver\");\nvar path_1 = require(\"path\");\nvar syntaxKind_1 = require(\"../../util/syntaxKind\");\nvar kinds = syntaxKind_1.current();\nvar UrlResolver = (function (_super) {\n    __extends(UrlResolver, _super);\n    function UrlResolver(pathResolver) {\n        var _this = _super.call(this) || this;\n        _this.pathResolver = pathResolver;\n        return _this;\n    }\n    UrlResolver.prototype.resolve = function (d) {\n        var _this = this;\n        var templateUrl = this.getTemplateUrl(d);\n        var styleUrls = this.getStyleUrls(d);\n        var targetPath = this.getProgramFilePath(d);\n        if (targetPath) {\n            var componentPath_1 = path_1.dirname(targetPath);\n            return {\n                templateUrl: config_1.Config.resolveUrl(this.pathResolver.resolve(templateUrl, componentPath_1), d),\n                styleUrls: styleUrls.map(function (p) {\n                    return config_1.Config.resolveUrl(_this.pathResolver.resolve(p, componentPath_1), d);\n                })\n            };\n        }\n        else {\n            return {\n                templateUrl: config_1.Config.resolveUrl(null, d),\n                styleUrls: []\n            };\n        }\n    };\n    UrlResolver.prototype.getProgramFilePath = function (d) {\n        var current = d;\n        while (current) {\n            if (current.kind === kinds.SourceFile) {\n                return current.path || current.fileName;\n            }\n            current = current.parent;\n        }\n        return undefined;\n    };\n    return UrlResolver;\n}(abstractResolver_1.AbstractResolver));\nexports.UrlResolver = UrlResolver;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/angular/urlResolvers/abstractResolver.js":"\"use strict\";\nvar syntaxKind_1 = require(\"../../util/syntaxKind\");\nvar utils_1 = require(\"../../util/utils\");\nvar kinds = syntaxKind_1.current();\nvar AbstractResolver = (function () {\n    function AbstractResolver() {\n    }\n    AbstractResolver.prototype.getTemplateUrl = function (decorator) {\n        var arg = this.getDecoratorArgument(decorator);\n        if (!arg) {\n            return null;\n        }\n        var prop = arg.properties.filter(function (p) {\n            if (p.name.text === 'templateUrl' && utils_1.isSimpleTemplateString(p.initializer)) {\n                return true;\n            }\n            return false;\n        }).pop();\n        if (prop) {\n            return prop.initializer.text;\n        }\n        else {\n            return null;\n        }\n    };\n    AbstractResolver.prototype.getStyleUrls = function (decorator) {\n        var arg = this.getDecoratorArgument(decorator);\n        if (!arg) {\n            return [];\n        }\n        var prop = arg.properties.filter(function (p) {\n            if (p.name.text === 'styleUrls' && p.initializer.kind === kinds.ArrayLiteralExpression) {\n                return true;\n            }\n            return false;\n        }).pop();\n        if (prop) {\n            return prop.initializer.elements.filter(function (e) {\n                return utils_1.isSimpleTemplateString(e);\n            }).map(function (e) {\n                return e.text;\n            });\n        }\n        else {\n            return [];\n        }\n    };\n    AbstractResolver.prototype.getDecoratorArgument = function (decorator) {\n        var expr = decorator.expression;\n        if (expr && expr.arguments && expr.arguments.length) {\n            var arg = expr.arguments[0];\n            if (arg.kind === kinds.ObjectLiteralExpression && arg.properties) {\n                return arg;\n            }\n        }\n        return null;\n    };\n    return AbstractResolver;\n}());\nexports.AbstractResolver = AbstractResolver;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/angular/urlResolvers/pathResolver.js":"\"use strict\";\nvar path_1 = require(\"path\");\nvar PathResolver = (function () {\n    function PathResolver() {\n    }\n    PathResolver.prototype.resolve = function (path, relative) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        return path_1.join(relative, path);\n    };\n    return PathResolver;\n}());\nexports.PathResolver = PathResolver;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/util/logger.js":"\"use strict\";\nvar config_1 = require(\"../angular/config\");\nvar Logger = (function () {\n    function Logger(level) {\n        this.level = level;\n    }\n    Logger.prototype.error = function () {\n        var msg = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            msg[_i] = arguments[_i];\n        }\n        if (this.level & config_1.LogLevel.Error) {\n            console.error.apply(console, msg);\n        }\n    };\n    Logger.prototype.info = function () {\n        var msg = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            msg[_i] = arguments[_i];\n        }\n        if (this.level && config_1.LogLevel.Info) {\n            console.info.apply(console, msg);\n        }\n    };\n    Logger.prototype.debug = function () {\n        var msg = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            msg[_i] = arguments[_i];\n        }\n        if (this.level && config_1.LogLevel.Debug) {\n            console.log.apply(console, msg);\n        }\n    };\n    return Logger;\n}());\nexports.Logger = Logger;\nexports.logger = new Logger(config_1.Config.logLevel);\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/util/function.js":"\"use strict\";\nfunction nullOrUndef(t) {\n    return t === null || t === undefined;\n}\nvar Maybe = (function () {\n    function Maybe(t) {\n        this.t = t;\n    }\n    Maybe.lift = function (t) {\n        if (nullOrUndef(t)) {\n            return Maybe.nothing;\n        }\n        return new Maybe(t);\n    };\n    Maybe.all = function (t0, t1) {\n        return t0.bind(function (_t0) { return t1.fmap(function (_t1) { return [_t0, _t1]; }); });\n    };\n    Maybe.prototype.bind = function (fn) {\n        if (!nullOrUndef(this.t)) {\n            return fn(this.t);\n        }\n        return Maybe.nothing;\n    };\n    Maybe.prototype.fmap = function (fn) {\n        return this.bind(function (t) { return Maybe.lift(fn(t)); });\n    };\n    Object.defineProperty(Maybe.prototype, \"isNothing\", {\n        get: function () {\n            return nullOrUndef(this.t);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Maybe.prototype, \"isSomething\", {\n        get: function () {\n            return !nullOrUndef(this.t);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Maybe.prototype.catch = function (def) {\n        if (this.isNothing) {\n            return def();\n        }\n        return this;\n    };\n    Maybe.prototype.unwrap = function () {\n        return this.t;\n    };\n    ;\n    return Maybe;\n}());\nMaybe.nothing = new Maybe(undefined);\nexports.Maybe = Maybe;\nfunction unwrapFirst(ts) {\n    var f = ts.find(function (t) { return t.isSomething; });\n    if (!!f) {\n        return f.unwrap();\n    }\n    return undefined;\n}\nexports.unwrapFirst = unwrapFirst;\nfunction all() {\n    var preds = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        preds[_i] = arguments[_i];\n    }\n    return function (t) { return !preds.find(function (p) { return !p(t); }); };\n}\nexports.all = all;\nfunction any() {\n    var preds = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        preds[_i] = arguments[_i];\n    }\n    return function (t) { return !!preds.find(function (p) { return p(t); }); };\n}\nexports.any = any;\nfunction ifTrue(pred) {\n    return function (t) { return (pred(t)) ? Maybe.lift(t) : Maybe.nothing; };\n}\nexports.ifTrue = ifTrue;\nfunction listToMaybe(ms) {\n    var unWrapped = ms.filter(function (m) { return m.isSomething; }).map(function (m) { return m.unwrap(); });\n    return unWrapped.length !== 0 ? Maybe.lift(unWrapped) : Maybe.nothing;\n}\nexports.listToMaybe = listToMaybe;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/util/astQuery.js":"\"use strict\";\nvar syntaxKind_1 = require(\"./syntaxKind\");\nvar function_1 = require(\"./function\");\nvar kinds = syntaxKind_1.current();\nfunction isCallExpression(expr) {\n    return expr && expr.kind === kinds.CallExpression;\n}\nexports.isCallExpression = isCallExpression;\nfunction callExpression(dec) {\n    return function_1.Maybe.lift(dec.expression)\n        .fmap(function (expr) { return isCallExpression(expr) ? expr : undefined; });\n}\nexports.callExpression = callExpression;\nfunction isPropertyAssignment(expr) {\n    return expr && expr.kind === kinds.PropertyAssignment;\n}\nexports.isPropertyAssignment = isPropertyAssignment;\nfunction isSimpleTemplateString(expr) {\n    return expr && expr.kind === kinds.StringLiteral || expr.kind === kinds.NoSubstitutionTemplateLiteral;\n}\nexports.isSimpleTemplateString = isSimpleTemplateString;\nfunction isArrayLiteralExpression(expr) {\n    return expr && expr.kind === kinds.ArrayLiteralExpression;\n}\nexports.isArrayLiteralExpression = isArrayLiteralExpression;\nfunction hasProperties(expr) {\n    return expr && !!expr.properties;\n}\nexports.hasProperties = hasProperties;\nfunction isObjectLiteralExpression(expr) {\n    return expr && expr.kind === kinds.ObjectLiteralExpression;\n}\nexports.isObjectLiteralExpression = isObjectLiteralExpression;\nfunction objectLiteralExpression(expr) {\n    return function_1.Maybe.lift(expr.arguments[0])\n        .fmap(function (arg0) { return (isObjectLiteralExpression(arg0) ? arg0 : undefined); });\n}\nexports.objectLiteralExpression = objectLiteralExpression;\nfunction isIdentifier(expr) {\n    return expr && expr.kind === kinds.Identifier;\n}\nexports.isIdentifier = isIdentifier;\nfunction withIdentifier(identifier) {\n    return function_1.ifTrue(function (expr) { return (isIdentifier(expr.expression) && expr.expression.text === identifier); });\n}\nexports.withIdentifier = withIdentifier;\nfunction isProperty(propName, p) {\n    return isPropertyAssignment(p) && isIdentifier(p.name) && p.name.text === propName;\n}\nexports.isProperty = isProperty;\nfunction getInitializer(p) {\n    return function_1.Maybe.lift((isPropertyAssignment(p) && isIdentifier(p.name)) ? p.initializer : undefined);\n}\nexports.getInitializer = getInitializer;\nfunction getStringInitializerFromProperty(propertyName, ps) {\n    var property = ps.find(function (p) { return isProperty(propertyName, p); });\n    return getInitializer(property)\n        .fmap(function (expr) { return isSimpleTemplateString(expr) ? expr : undefined; });\n}\nexports.getStringInitializerFromProperty = getStringInitializerFromProperty;\nfunction decoratorArgument(dec) {\n    return function_1.Maybe.lift(dec)\n        .bind(callExpression)\n        .bind(objectLiteralExpression);\n}\nexports.decoratorArgument = decoratorArgument;\nfunction isDecorator(expr) {\n    return expr && expr.kind === kinds.Decorator;\n}\nexports.isDecorator = isDecorator;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/util/ngQuery.js":"\"use strict\";\nvar astQuery_1 = require(\"./astQuery\");\nfunction getInlineStyle(dec) {\n    return astQuery_1.decoratorArgument(dec)\n        .bind(function (expr) {\n        var property = expr.properties.find(function (p) { return astQuery_1.isProperty('styles', p); });\n        return astQuery_1.getInitializer(property)\n            .fmap(function (expr) {\n            return astQuery_1.isArrayLiteralExpression(expr) ? expr : undefined;\n        });\n    });\n}\nexports.getInlineStyle = getInlineStyle;\nfunction getTemplateUrl(dec) {\n    return astQuery_1.decoratorArgument(dec)\n        .bind(function (expr) {\n        return astQuery_1.getStringInitializerFromProperty('templateUrl', expr.properties);\n    });\n}\nexports.getTemplateUrl = getTemplateUrl;\nfunction getTemplate(dec) {\n    return astQuery_1.decoratorArgument(dec)\n        .bind(function (expr) {\n        return astQuery_1.getStringInitializerFromProperty('template', expr.properties);\n    });\n}\nexports.getTemplate = getTemplate;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/angular/ng2WalkerFactoryUtils.js":"\"use strict\";\nvar metadataReader_1 = require(\"./metadataReader\");\nvar urlResolver_1 = require(\"./urlResolvers/urlResolver\");\nvar fsFileResolver_1 = require(\"./fileResolver/fsFileResolver\");\nvar basicCssAstVisitor_1 = require(\"./styles/basicCssAstVisitor\");\nvar recursiveAngularExpressionVisitor_1 = require(\"./templates/recursiveAngularExpressionVisitor\");\nvar basicTemplateAstVisitor_1 = require(\"./templates/basicTemplateAstVisitor\");\nvar pathResolver_1 = require(\"./urlResolvers/pathResolver\");\nexports.ng2WalkerFactoryUtils = {\n    defaultConfig: function () {\n        return {\n            templateVisitorCtrl: basicTemplateAstVisitor_1.BasicTemplateAstVisitor,\n            expressionVisitorCtrl: recursiveAngularExpressionVisitor_1.RecursiveAngularExpressionVisitor,\n            cssVisitorCtrl: basicCssAstVisitor_1.BasicCssAstVisitor\n        };\n    },\n    defaultMetadataReader: function () {\n        return new metadataReader_1.MetadataReader(new fsFileResolver_1.FsFileResolver(), new urlResolver_1.UrlResolver(new pathResolver_1.PathResolver()));\n    },\n    normalizeConfig: function (config) {\n        return Object.assign(this.defaultConfig(), config || {});\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/angular/fileResolver/fsFileResolver.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar fs_1 = require(\"fs\");\nvar fileResolver_1 = require(\"./fileResolver\");\nvar FsFileResolver = (function (_super) {\n    __extends(FsFileResolver, _super);\n    function FsFileResolver() {\n        return _super.apply(this, arguments) || this;\n    }\n    FsFileResolver.prototype.resolve = function (path) {\n        return fs_1.readFileSync(path).toString();\n    };\n    return FsFileResolver;\n}(fileResolver_1.FileResolver));\nexports.FsFileResolver = FsFileResolver;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/angular/fileResolver/fileResolver.js":"\"use strict\";\nvar FileResolver = (function () {\n    function FileResolver() {\n    }\n    return FileResolver;\n}());\nexports.FileResolver = FileResolver;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/angular/styles/basicCssAstVisitor.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar sourceMappingVisitor_1 = require(\"../sourceMappingVisitor\");\nvar BasicCssAstVisitor = (function (_super) {\n    __extends(BasicCssAstVisitor, _super);\n    function BasicCssAstVisitor(sourceFile, _originalOptions, context, style, templateStart) {\n        var _this = _super.call(this, sourceFile, _originalOptions, style.style, templateStart) || this;\n        _this._originalOptions = _originalOptions;\n        _this.context = context;\n        _this.templateStart = templateStart;\n        return _this;\n    }\n    BasicCssAstVisitor.prototype.visitCssValue = function (ast, context) { };\n    BasicCssAstVisitor.prototype.visitCssInlineRule = function (ast, context) { };\n    BasicCssAstVisitor.prototype.visitCssAtRulePredicate = function (ast, context) { };\n    BasicCssAstVisitor.prototype.visitCssKeyframeRule = function (ast, context) {\n        ast.block.visit(this, context);\n    };\n    BasicCssAstVisitor.prototype.visitCssKeyframeDefinition = function (ast, context) {\n        ast.block.visit(this, context);\n    };\n    BasicCssAstVisitor.prototype.visitCssMediaQueryRule = function (ast, context) {\n        ast.query.visit(this, context);\n        ast.block.visit(this, context);\n    };\n    BasicCssAstVisitor.prototype.visitCssSelectorRule = function (ast, context) {\n        var _this = this;\n        ast.selectors.forEach(function (selAst) { selAst.visit(_this, context); });\n        ast.block.visit(this, context);\n    };\n    BasicCssAstVisitor.prototype.visitCssSelector = function (ast, context) {\n        var _this = this;\n        ast.selectorParts.forEach(function (simpleAst) { simpleAst.visit(_this, context); });\n    };\n    BasicCssAstVisitor.prototype.visitCssSimpleSelector = function (ast, context) {\n        var _this = this;\n        ast.pseudoSelectors.forEach(function (pseudoAst) { pseudoAst.visit(_this, context); });\n    };\n    BasicCssAstVisitor.prototype.visitCssPseudoSelector = function (ast, context) { };\n    BasicCssAstVisitor.prototype.visitCssDefinition = function (ast, context) {\n        ast.value.visit(this, context);\n    };\n    BasicCssAstVisitor.prototype.visitCssBlock = function (ast, context) {\n        var _this = this;\n        ast.entries.forEach(function (entryAst) { entryAst.visit(_this, context); });\n    };\n    BasicCssAstVisitor.prototype.visitCssStylesBlock = function (ast, context) {\n        var _this = this;\n        ast.definitions.forEach(function (definitionAst) { definitionAst.visit(_this, context); });\n    };\n    BasicCssAstVisitor.prototype.visitCssStyleSheet = function (ast, context) {\n        var _this = this;\n        ast.rules.forEach(function (ruleAst) { ruleAst.visit(_this, context); });\n    };\n    BasicCssAstVisitor.prototype.visitCssUnknownRule = function (ast, context) { };\n    BasicCssAstVisitor.prototype.visitCssUnknownTokenList = function (ast, context) { };\n    return BasicCssAstVisitor;\n}(sourceMappingVisitor_1.SourceMappingVisitor));\nexports.BasicCssAstVisitor = BasicCssAstVisitor;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/angular/sourceMappingVisitor.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tslint_1 = require(\"tslint\");\nvar source_map_1 = require(\"source-map\");\nvar LineFeed = 0x0A;\nvar CarriageReturn = 0x0D;\nvar MaxAsciiCharacter = 0x7F;\nvar LineSeparator = 0x2028;\nvar ParagraphSeparator = 0x2029;\nfunction isLineBreak(ch) {\n    return ch === LineFeed ||\n        ch === CarriageReturn ||\n        ch === LineSeparator ||\n        ch === ParagraphSeparator;\n}\nexports.isLineBreak = isLineBreak;\nfunction binarySearch(array, value, comparer, offset) {\n    if (!array || array.length === 0) {\n        return -1;\n    }\n    var low = offset || 0;\n    var high = array.length - 1;\n    comparer = comparer !== undefined\n        ? comparer\n        : function (v1, v2) { return (v1 < v2 ? -1 : (v1 > v2 ? 1 : 0)); };\n    while (low <= high) {\n        var middle = low + ((high - low) >> 1);\n        var midValue = array[middle];\n        if (comparer(midValue, value) === 0) {\n            return middle;\n        }\n        else if (comparer(midValue, value) > 0) {\n            high = middle - 1;\n        }\n        else {\n            low = middle + 1;\n        }\n    }\n    return ~low;\n}\nfunction getLineAndCharacterOfPosition(sourceFile, position) {\n    return computeLineAndCharacterOfPosition(computeLineStarts(sourceFile), position);\n}\nfunction getPositionOfLineAndCharacter(sourceFile, line, character) {\n    return computePositionOfLineAndCharacter(computeLineStarts(sourceFile), line, character);\n}\nfunction computePositionOfLineAndCharacter(lineStarts, line, character) {\n    return lineStarts[line] + character;\n}\nfunction computeLineAndCharacterOfPosition(lineStarts, position) {\n    var lineNumber = binarySearch(lineStarts, position);\n    if (lineNumber < 0) {\n        lineNumber = ~lineNumber - 1;\n    }\n    return {\n        line: lineNumber,\n        character: position - lineStarts[lineNumber]\n    };\n}\nfunction computeLineStarts(text) {\n    var result = new Array();\n    var pos = 0;\n    var lineStart = 0;\n    while (pos < text.length) {\n        var ch = text.charCodeAt(pos);\n        pos++;\n        switch (ch) {\n            case CarriageReturn:\n                if (text.charCodeAt(pos) === LineFeed) {\n                    pos++;\n                }\n            case LineFeed:\n                result.push(lineStart);\n                lineStart = pos;\n                break;\n            default:\n                if (ch > MaxAsciiCharacter && isLineBreak(ch)) {\n                    result.push(lineStart);\n                    lineStart = pos;\n                }\n                break;\n        }\n    }\n    result.push(lineStart);\n    return result;\n}\nvar SourceMappingVisitor = (function (_super) {\n    __extends(SourceMappingVisitor, _super);\n    function SourceMappingVisitor(sourceFile, options, codeWithMap, basePosition) {\n        var _this = _super.call(this, sourceFile, options) || this;\n        _this.codeWithMap = codeWithMap;\n        _this.basePosition = basePosition;\n        if (_this.codeWithMap.map) {\n            _this.consumer = new source_map_1.SourceMapConsumer(_this.codeWithMap.map);\n        }\n        return _this;\n    }\n    SourceMappingVisitor.prototype.createFailure = function (s, l, message, fix) {\n        var _a = this.getMappedInterval(s, l), start = _a.start, length = _a.length;\n        return _super.prototype.createFailure.call(this, start, length, message, fix);\n    };\n    SourceMappingVisitor.prototype.createReplacement = function (s, l, replacement) {\n        var _a = this.getMappedInterval(s, l), start = _a.start, length = _a.length;\n        return _super.prototype.createReplacement.call(this, start, length, replacement);\n    };\n    SourceMappingVisitor.prototype.getSourcePosition = function (pos) {\n        if (this.consumer) {\n            try {\n                var absPos = getLineAndCharacterOfPosition(this.codeWithMap.code, pos);\n                var result = this.consumer.originalPositionFor({ line: absPos.line + 1, column: absPos.character + 1 });\n                absPos = { line: result.line - 1, character: result.column - 1 };\n                pos = getPositionOfLineAndCharacter(this.codeWithMap.source, absPos.line, absPos.character);\n            }\n            catch (e) {\n                console.log(e);\n            }\n        }\n        return pos + this.basePosition;\n    };\n    SourceMappingVisitor.prototype.getMappedInterval = function (start, length) {\n        var end = start + length;\n        start = this.getSourcePosition(start);\n        end = this.getSourcePosition(end);\n        return { start: start, length: end - start };\n    };\n    return SourceMappingVisitor;\n}(tslint_1.RuleWalker));\nexports.SourceMappingVisitor = SourceMappingVisitor;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/angular/templates/recursiveAngularExpressionVisitor.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar sourceMappingVisitor_1 = require(\"../sourceMappingVisitor\");\nvar RecursiveAngularExpressionVisitor = (function (_super) {\n    __extends(RecursiveAngularExpressionVisitor, _super);\n    function RecursiveAngularExpressionVisitor(sourceFile, options, context, basePosition) {\n        var _this = _super.call(this, sourceFile, options, context.template.template, basePosition) || this;\n        _this.context = context;\n        _this.basePosition = basePosition;\n        _this.preDefinedVariables = [];\n        return _this;\n    }\n    RecursiveAngularExpressionVisitor.prototype.visit = function (ast, context) {\n        ast.visit(this);\n        return null;\n    };\n    RecursiveAngularExpressionVisitor.prototype.visitBinary = function (ast, context) {\n        ast.left.visit(this);\n        ast.right.visit(this);\n        return null;\n    };\n    RecursiveAngularExpressionVisitor.prototype.visitChain = function (ast, context) { return this.visitAll(ast.expressions, context); };\n    RecursiveAngularExpressionVisitor.prototype.visitConditional = function (ast, context) {\n        ast.condition.visit(this);\n        ast.trueExp.visit(this);\n        ast.falseExp.visit(this);\n        return null;\n    };\n    RecursiveAngularExpressionVisitor.prototype.visitPipe = function (ast, context) {\n        ast.exp.visit(this);\n        this.visitAll(ast.args, context);\n        return null;\n    };\n    RecursiveAngularExpressionVisitor.prototype.visitFunctionCall = function (ast, context) {\n        ast.target.visit(this);\n        this.visitAll(ast.args, context);\n        return null;\n    };\n    RecursiveAngularExpressionVisitor.prototype.visitImplicitReceiver = function (ast, context) { return null; };\n    RecursiveAngularExpressionVisitor.prototype.visitInterpolation = function (ast, context) {\n        var _this = this;\n        ast.expressions.forEach(function (e, i) { return _this.visit(e, context); });\n        return null;\n    };\n    RecursiveAngularExpressionVisitor.prototype.visitKeyedRead = function (ast, context) {\n        ast.obj.visit(this);\n        ast.key.visit(this);\n        return null;\n    };\n    RecursiveAngularExpressionVisitor.prototype.visitKeyedWrite = function (ast, context) {\n        ast.obj.visit(this);\n        ast.key.visit(this);\n        ast.value.visit(this);\n        return null;\n    };\n    RecursiveAngularExpressionVisitor.prototype.visitLiteralArray = function (ast, context) {\n        return this.visitAll(ast.expressions, context);\n    };\n    RecursiveAngularExpressionVisitor.prototype.visitLiteralMap = function (ast, context) { return this.visitAll(ast.values, context); };\n    RecursiveAngularExpressionVisitor.prototype.visitLiteralPrimitive = function (ast, context) { return null; };\n    RecursiveAngularExpressionVisitor.prototype.visitMethodCall = function (ast, context) {\n        ast.receiver.visit(this);\n        return this.visitAll(ast.args, context);\n    };\n    RecursiveAngularExpressionVisitor.prototype.visitPrefixNot = function (ast, context) {\n        ast.expression.visit(this);\n        return null;\n    };\n    RecursiveAngularExpressionVisitor.prototype.visitPropertyRead = function (ast, context) {\n        ast.receiver.visit(this);\n        return null;\n    };\n    RecursiveAngularExpressionVisitor.prototype.visitPropertyWrite = function (ast, context) {\n        ast.receiver.visit(this);\n        ast.value.visit(this);\n        return null;\n    };\n    RecursiveAngularExpressionVisitor.prototype.visitSafePropertyRead = function (ast, context) {\n        ast.receiver.visit(this);\n        return null;\n    };\n    RecursiveAngularExpressionVisitor.prototype.visitSafeMethodCall = function (ast, context) {\n        ast.receiver.visit(this);\n        return this.visitAll(ast.args, context);\n    };\n    RecursiveAngularExpressionVisitor.prototype.visitAll = function (asts, context) {\n        var _this = this;\n        asts.forEach(function (ast) { return ast.visit(_this, context); });\n        return null;\n    };\n    RecursiveAngularExpressionVisitor.prototype.visitQuote = function (ast, context) { return null; };\n    return RecursiveAngularExpressionVisitor;\n}(sourceMappingVisitor_1.SourceMappingVisitor));\nexports.RecursiveAngularExpressionVisitor = RecursiveAngularExpressionVisitor;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/angular/templates/basicTemplateAstVisitor.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ast = require(\"@angular/compiler\");\nvar expressionTypes_1 = require(\"../expressionTypes\");\nvar recursiveAngularExpressionVisitor_1 = require(\"./recursiveAngularExpressionVisitor\");\nvar sourceMappingVisitor_1 = require(\"../sourceMappingVisitor\");\nvar getExpressionDisplacement = function (binding) {\n    var attrLen = 0;\n    var valLen = 0;\n    var totalLength = 0;\n    var result = 0;\n    if (binding instanceof ast.BoundEventAst || binding instanceof ast.BoundElementPropertyAst) {\n        var subBindingLen = 0;\n        if (binding instanceof ast.BoundElementPropertyAst) {\n            var prop = binding;\n            switch (prop.type) {\n                case ast.PropertyBindingType.Animation:\n                    subBindingLen = 'animate'.length + 1;\n                    break;\n                case ast.PropertyBindingType.Attribute:\n                    subBindingLen = 'attr'.length + 1;\n                    break;\n                case ast.PropertyBindingType.Class:\n                    subBindingLen = 'class'.length + 1;\n                    break;\n                case ast.PropertyBindingType.Style:\n                    subBindingLen = 'style'.length + 1;\n                    break;\n            }\n        }\n        attrLen = binding.name.length + 4 + subBindingLen;\n        if (binding instanceof ast.BoundEventAst) {\n            valLen = binding.handler.span.end;\n        }\n        else {\n            valLen = binding.value.span.end;\n        }\n        totalLength = binding.sourceSpan.end.offset - binding.sourceSpan.start.offset;\n        var whitespace = totalLength - (attrLen + valLen) - 1;\n        result = whitespace + attrLen + binding.sourceSpan.start.offset;\n    }\n    else if (binding instanceof ast.BoundTextAst) {\n        result = binding.sourceSpan.start.offset;\n    }\n    return result;\n};\nvar BasicTemplateAstVisitor = (function (_super) {\n    __extends(BasicTemplateAstVisitor, _super);\n    function BasicTemplateAstVisitor(sourceFile, _originalOptions, context, templateStart, expressionVisitorCtrl) {\n        if (expressionVisitorCtrl === void 0) { expressionVisitorCtrl = recursiveAngularExpressionVisitor_1.RecursiveAngularExpressionVisitor; }\n        var _this = _super.call(this, sourceFile, _originalOptions, context.template.template, templateStart) || this;\n        _this._originalOptions = _originalOptions;\n        _this.context = context;\n        _this.templateStart = templateStart;\n        _this.expressionVisitorCtrl = expressionVisitorCtrl;\n        _this._variables = [];\n        return _this;\n    }\n    BasicTemplateAstVisitor.prototype.visitNg2TemplateAST = function (ast, templateStart) {\n        var _this = this;\n        var templateVisitor = new this.expressionVisitorCtrl(this.getSourceFile(), this._originalOptions, this.context, templateStart);\n        templateVisitor.preDefinedVariables = this._variables;\n        templateVisitor.visit(ast);\n        templateVisitor.getFailures().forEach(function (f) { return _this.addFailure(f); });\n    };\n    BasicTemplateAstVisitor.prototype.visit = function (node, context) {\n        node.visit(this, context);\n    };\n    BasicTemplateAstVisitor.prototype.visitNgContent = function (ast, context) { };\n    BasicTemplateAstVisitor.prototype.visitEmbeddedTemplate = function (ast, context) {\n        var _this = this;\n        ast.variables.forEach(function (v) { return _this.visit(v, context); });\n        ast.children.forEach(function (e) { return _this.visit(e, context); });\n        ast.outputs.forEach(function (o) { return _this.visit(o, context); });\n        ast.attrs.forEach(function (a) { return _this.visit(a, context); });\n        ast.references.forEach(function (r) { return _this.visit(r, context); });\n        ast.directives.forEach(function (d) { return _this.visit(d, context); });\n    };\n    BasicTemplateAstVisitor.prototype.visitElement = function (element, context) {\n        var _this = this;\n        element.references.forEach(function (r) { return _this.visit(r, context); });\n        element.inputs.forEach(function (i) { return _this.visit(i, context); });\n        element.outputs.forEach(function (o) { return _this.visit(o, context); });\n        element.attrs.forEach(function (a) { return _this.visit(a, context); });\n        element.children.forEach(function (e) { return _this.visit(e, context); });\n        element.directives.forEach(function (d) { return _this.visit(d, context); });\n    };\n    BasicTemplateAstVisitor.prototype.visitReference = function (ast, context) { };\n    BasicTemplateAstVisitor.prototype.visitVariable = function (ast, context) {\n        this._variables.push(ast.name);\n    };\n    BasicTemplateAstVisitor.prototype.visitEvent = function (ast, context) {\n        if (this._variables.indexOf('$event') < 0) {\n            this._variables.push('$event');\n        }\n        this.visitNg2TemplateAST(ast.handler, this.templateStart + getExpressionDisplacement(ast));\n        this._variables.splice(this._variables.indexOf('$event'), 1);\n    };\n    BasicTemplateAstVisitor.prototype.visitElementProperty = function (prop, context) {\n        var ast = prop.value.ast;\n        ast.interpolateExpression = prop.value.source;\n        this.visitNg2TemplateAST(prop.value, this.templateStart + getExpressionDisplacement(prop));\n    };\n    BasicTemplateAstVisitor.prototype.visitAttr = function (ast, context) { };\n    BasicTemplateAstVisitor.prototype.visitBoundText = function (text, context) {\n        if (expressionTypes_1.ExpTypes.ASTWithSource(text.value)) {\n            var ast_1 = text.value.ast;\n            ast_1.interpolateExpression = text.value.source;\n            this.visitNg2TemplateAST(ast_1, this.templateStart + getExpressionDisplacement(text));\n        }\n    };\n    BasicTemplateAstVisitor.prototype.visitText = function (text, context) { };\n    BasicTemplateAstVisitor.prototype.visitDirective = function (ast, context) {\n        var _this = this;\n        ast.inputs.forEach(function (o) { return _this.visit(o, context); });\n        ast.hostProperties.forEach(function (p) { return _this.visit(p, context); });\n        ast.hostEvents.forEach(function (e) { return _this.visit(e, context); });\n    };\n    BasicTemplateAstVisitor.prototype.visitDirectiveProperty = function (prop, context) {\n        if (expressionTypes_1.ExpTypes.ASTWithSource(prop.value)) {\n            var ast_2 = prop.value.ast;\n            this.visitNg2TemplateAST(prop.value, this.templateStart + getExpressionDisplacement(prop));\n        }\n    };\n    return BasicTemplateAstVisitor;\n}(sourceMappingVisitor_1.SourceMappingVisitor));\nexports.BasicTemplateAstVisitor = BasicTemplateAstVisitor;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/util/ngVersion.js":"\"use strict\";\nvar core_1 = require(\"@angular/core\");\nvar semver_dsl_1 = require(\"semver-dsl\");\nexports.SemVerDSL = semver_dsl_1.SemVerDSL(core_1.VERSION.full);\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/angular/styles/chars.js":"\"use strict\";\nexports.$EOF = 0;\nexports.$TAB = 9;\nexports.$LF = 10;\nexports.$VTAB = 11;\nexports.$FF = 12;\nexports.$CR = 13;\nexports.$SPACE = 32;\nexports.$BANG = 33;\nexports.$DQ = 34;\nexports.$HASH = 35;\nexports.$$ = 36;\nexports.$PERCENT = 37;\nexports.$AMPERSAND = 38;\nexports.$SQ = 39;\nexports.$LPAREN = 40;\nexports.$RPAREN = 41;\nexports.$STAR = 42;\nexports.$PLUS = 43;\nexports.$COMMA = 44;\nexports.$MINUS = 45;\nexports.$PERIOD = 46;\nexports.$SLASH = 47;\nexports.$COLON = 58;\nexports.$SEMICOLON = 59;\nexports.$LT = 60;\nexports.$EQ = 61;\nexports.$GT = 62;\nexports.$QUESTION = 63;\nexports.$0 = 48;\nexports.$9 = 57;\nexports.$A = 65;\nexports.$E = 69;\nexports.$F = 70;\nexports.$X = 88;\nexports.$Z = 90;\nexports.$LBRACKET = 91;\nexports.$BACKSLASH = 92;\nexports.$RBRACKET = 93;\nexports.$CARET = 94;\nexports.$_ = 95;\nexports.$a = 97;\nexports.$e = 101;\nexports.$f = 102;\nexports.$n = 110;\nexports.$r = 114;\nexports.$t = 116;\nexports.$u = 117;\nexports.$v = 118;\nexports.$x = 120;\nexports.$z = 122;\nexports.$LBRACE = 123;\nexports.$BAR = 124;\nexports.$RBRACE = 125;\nexports.$NBSP = 160;\nexports.$PIPE = 124;\nexports.$TILDA = 126;\nexports.$AT = 64;\nexports.$BT = 96;\nfunction isWhitespace(code) {\n    return (code >= exports.$TAB && code <= exports.$SPACE) || (code === exports.$NBSP);\n}\nexports.isWhitespace = isWhitespace;\nfunction isDigit(code) {\n    return exports.$0 <= code && code <= exports.$9;\n}\nexports.isDigit = isDigit;\nfunction isAsciiLetter(code) {\n    return code >= exports.$a && code <= exports.$z || code >= exports.$A && code <= exports.$Z;\n}\nexports.isAsciiLetter = isAsciiLetter;\nfunction isAsciiHexDigit(code) {\n    return code >= exports.$a && code <= exports.$f || code >= exports.$A && code <= exports.$F || isDigit(code);\n}\nexports.isAsciiHexDigit = isAsciiHexDigit;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/angular/styles/cssAst.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar cssLexer_1 = require(\"./cssLexer\");\nvar BlockType;\n(function (BlockType) {\n    BlockType[BlockType[\"Import\"] = 0] = \"Import\";\n    BlockType[BlockType[\"Charset\"] = 1] = \"Charset\";\n    BlockType[BlockType[\"Namespace\"] = 2] = \"Namespace\";\n    BlockType[BlockType[\"Supports\"] = 3] = \"Supports\";\n    BlockType[BlockType[\"Keyframes\"] = 4] = \"Keyframes\";\n    BlockType[BlockType[\"MediaQuery\"] = 5] = \"MediaQuery\";\n    BlockType[BlockType[\"Selector\"] = 6] = \"Selector\";\n    BlockType[BlockType[\"FontFace\"] = 7] = \"FontFace\";\n    BlockType[BlockType[\"Page\"] = 8] = \"Page\";\n    BlockType[BlockType[\"Document\"] = 9] = \"Document\";\n    BlockType[BlockType[\"Viewport\"] = 10] = \"Viewport\";\n    BlockType[BlockType[\"Unsupported\"] = 11] = \"Unsupported\";\n})(BlockType = exports.BlockType || (exports.BlockType = {}));\nvar CssAst = (function () {\n    function CssAst(location) {\n        this.location = location;\n    }\n    Object.defineProperty(CssAst.prototype, \"start\", {\n        get: function () { return this.location.start; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CssAst.prototype, \"end\", {\n        get: function () { return this.location.end; },\n        enumerable: true,\n        configurable: true\n    });\n    return CssAst;\n}());\nexports.CssAst = CssAst;\nvar CssStyleValueAst = (function (_super) {\n    __extends(CssStyleValueAst, _super);\n    function CssStyleValueAst(location, tokens, strValue) {\n        var _this = _super.call(this, location) || this;\n        _this.tokens = tokens;\n        _this.strValue = strValue;\n        return _this;\n    }\n    CssStyleValueAst.prototype.visit = function (visitor, context) { return visitor.visitCssValue(this); };\n    return CssStyleValueAst;\n}(CssAst));\nexports.CssStyleValueAst = CssStyleValueAst;\nvar CssRuleAst = (function (_super) {\n    __extends(CssRuleAst, _super);\n    function CssRuleAst(location) {\n        return _super.call(this, location) || this;\n    }\n    return CssRuleAst;\n}(CssAst));\nexports.CssRuleAst = CssRuleAst;\nvar CssBlockRuleAst = (function (_super) {\n    __extends(CssBlockRuleAst, _super);\n    function CssBlockRuleAst(location, type, block, name) {\n        if (name === void 0) { name = null; }\n        var _this = _super.call(this, location) || this;\n        _this.location = location;\n        _this.type = type;\n        _this.block = block;\n        _this.name = name;\n        return _this;\n    }\n    CssBlockRuleAst.prototype.visit = function (visitor, context) {\n        return visitor.visitCssBlock(this.block, context);\n    };\n    return CssBlockRuleAst;\n}(CssRuleAst));\nexports.CssBlockRuleAst = CssBlockRuleAst;\nvar CssKeyframeRuleAst = (function (_super) {\n    __extends(CssKeyframeRuleAst, _super);\n    function CssKeyframeRuleAst(location, name, block) {\n        return _super.call(this, location, BlockType.Keyframes, block, name) || this;\n    }\n    CssKeyframeRuleAst.prototype.visit = function (visitor, context) {\n        return visitor.visitCssKeyframeRule(this, context);\n    };\n    return CssKeyframeRuleAst;\n}(CssBlockRuleAst));\nexports.CssKeyframeRuleAst = CssKeyframeRuleAst;\nvar CssKeyframeDefinitionAst = (function (_super) {\n    __extends(CssKeyframeDefinitionAst, _super);\n    function CssKeyframeDefinitionAst(location, steps, block) {\n        var _this = _super.call(this, location, BlockType.Keyframes, block, mergeTokens(steps, ',')) || this;\n        _this.steps = steps;\n        return _this;\n    }\n    CssKeyframeDefinitionAst.prototype.visit = function (visitor, context) {\n        return visitor.visitCssKeyframeDefinition(this, context);\n    };\n    return CssKeyframeDefinitionAst;\n}(CssBlockRuleAst));\nexports.CssKeyframeDefinitionAst = CssKeyframeDefinitionAst;\nvar CssBlockDefinitionRuleAst = (function (_super) {\n    __extends(CssBlockDefinitionRuleAst, _super);\n    function CssBlockDefinitionRuleAst(location, strValue, type, query, block) {\n        var _this = _super.call(this, location, type, block) || this;\n        _this.strValue = strValue;\n        _this.query = query;\n        var firstCssToken = query.tokens[0];\n        _this.name = new cssLexer_1.CssToken(firstCssToken.index, firstCssToken.column, firstCssToken.line, cssLexer_1.CssTokenType.Identifier, _this.strValue);\n        return _this;\n    }\n    CssBlockDefinitionRuleAst.prototype.visit = function (visitor, context) {\n        return visitor.visitCssBlock(this.block, context);\n    };\n    return CssBlockDefinitionRuleAst;\n}(CssBlockRuleAst));\nexports.CssBlockDefinitionRuleAst = CssBlockDefinitionRuleAst;\nvar CssMediaQueryRuleAst = (function (_super) {\n    __extends(CssMediaQueryRuleAst, _super);\n    function CssMediaQueryRuleAst(location, strValue, query, block) {\n        return _super.call(this, location, strValue, BlockType.MediaQuery, query, block) || this;\n    }\n    CssMediaQueryRuleAst.prototype.visit = function (visitor, context) {\n        return visitor.visitCssMediaQueryRule(this, context);\n    };\n    return CssMediaQueryRuleAst;\n}(CssBlockDefinitionRuleAst));\nexports.CssMediaQueryRuleAst = CssMediaQueryRuleAst;\nvar CssAtRulePredicateAst = (function (_super) {\n    __extends(CssAtRulePredicateAst, _super);\n    function CssAtRulePredicateAst(location, strValue, tokens) {\n        var _this = _super.call(this, location) || this;\n        _this.strValue = strValue;\n        _this.tokens = tokens;\n        return _this;\n    }\n    CssAtRulePredicateAst.prototype.visit = function (visitor, context) {\n        return visitor.visitCssAtRulePredicate(this, context);\n    };\n    return CssAtRulePredicateAst;\n}(CssAst));\nexports.CssAtRulePredicateAst = CssAtRulePredicateAst;\nvar CssInlineRuleAst = (function (_super) {\n    __extends(CssInlineRuleAst, _super);\n    function CssInlineRuleAst(location, type, value) {\n        var _this = _super.call(this, location) || this;\n        _this.type = type;\n        _this.value = value;\n        return _this;\n    }\n    CssInlineRuleAst.prototype.visit = function (visitor, context) {\n        return visitor.visitCssInlineRule(this, context);\n    };\n    return CssInlineRuleAst;\n}(CssRuleAst));\nexports.CssInlineRuleAst = CssInlineRuleAst;\nvar CssSelectorRuleAst = (function (_super) {\n    __extends(CssSelectorRuleAst, _super);\n    function CssSelectorRuleAst(location, selectors, block) {\n        var _this = _super.call(this, location, BlockType.Selector, block) || this;\n        _this.selectors = selectors;\n        _this.strValue = selectors.map(function (selector) { return selector.strValue; }).join(',');\n        return _this;\n    }\n    CssSelectorRuleAst.prototype.visit = function (visitor, context) {\n        return visitor.visitCssSelectorRule(this, context);\n    };\n    return CssSelectorRuleAst;\n}(CssBlockRuleAst));\nexports.CssSelectorRuleAst = CssSelectorRuleAst;\nvar CssDefinitionAst = (function (_super) {\n    __extends(CssDefinitionAst, _super);\n    function CssDefinitionAst(location, property, value) {\n        var _this = _super.call(this, location) || this;\n        _this.property = property;\n        _this.value = value;\n        return _this;\n    }\n    CssDefinitionAst.prototype.visit = function (visitor, context) {\n        return visitor.visitCssDefinition(this, context);\n    };\n    return CssDefinitionAst;\n}(CssAst));\nexports.CssDefinitionAst = CssDefinitionAst;\nvar CssSelectorPartAst = (function (_super) {\n    __extends(CssSelectorPartAst, _super);\n    function CssSelectorPartAst(location) {\n        return _super.call(this, location) || this;\n    }\n    return CssSelectorPartAst;\n}(CssAst));\nexports.CssSelectorPartAst = CssSelectorPartAst;\nvar CssSelectorAst = (function (_super) {\n    __extends(CssSelectorAst, _super);\n    function CssSelectorAst(location, selectorParts) {\n        var _this = _super.call(this, location) || this;\n        _this.selectorParts = selectorParts;\n        _this.strValue = selectorParts.map(function (part) { return part.strValue; }).join('');\n        return _this;\n    }\n    CssSelectorAst.prototype.visit = function (visitor, context) {\n        return visitor.visitCssSelector(this, context);\n    };\n    return CssSelectorAst;\n}(CssSelectorPartAst));\nexports.CssSelectorAst = CssSelectorAst;\nvar CssSimpleSelectorAst = (function (_super) {\n    __extends(CssSimpleSelectorAst, _super);\n    function CssSimpleSelectorAst(location, tokens, strValue, pseudoSelectors, operator) {\n        var _this = _super.call(this, location) || this;\n        _this.tokens = tokens;\n        _this.strValue = strValue;\n        _this.pseudoSelectors = pseudoSelectors;\n        _this.operator = operator;\n        return _this;\n    }\n    CssSimpleSelectorAst.prototype.visit = function (visitor, context) {\n        return visitor.visitCssSimpleSelector(this, context);\n    };\n    return CssSimpleSelectorAst;\n}(CssSelectorPartAst));\nexports.CssSimpleSelectorAst = CssSimpleSelectorAst;\nvar CssPseudoSelectorAst = (function (_super) {\n    __extends(CssPseudoSelectorAst, _super);\n    function CssPseudoSelectorAst(location, strValue, name, tokens, innerSelectors) {\n        var _this = _super.call(this, location) || this;\n        _this.strValue = strValue;\n        _this.name = name;\n        _this.tokens = tokens;\n        _this.innerSelectors = innerSelectors;\n        return _this;\n    }\n    CssPseudoSelectorAst.prototype.visit = function (visitor, context) {\n        return visitor.visitCssPseudoSelector(this, context);\n    };\n    return CssPseudoSelectorAst;\n}(CssSelectorPartAst));\nexports.CssPseudoSelectorAst = CssPseudoSelectorAst;\nvar CssBlockAst = (function (_super) {\n    __extends(CssBlockAst, _super);\n    function CssBlockAst(location, entries) {\n        var _this = _super.call(this, location) || this;\n        _this.entries = entries;\n        return _this;\n    }\n    CssBlockAst.prototype.visit = function (visitor, context) { return visitor.visitCssBlock(this, context); };\n    return CssBlockAst;\n}(CssAst));\nexports.CssBlockAst = CssBlockAst;\nvar CssStylesBlockAst = (function (_super) {\n    __extends(CssStylesBlockAst, _super);\n    function CssStylesBlockAst(location, definitions) {\n        var _this = _super.call(this, location, definitions) || this;\n        _this.definitions = definitions;\n        return _this;\n    }\n    CssStylesBlockAst.prototype.visit = function (visitor, context) {\n        return visitor.visitCssStylesBlock(this, context);\n    };\n    return CssStylesBlockAst;\n}(CssBlockAst));\nexports.CssStylesBlockAst = CssStylesBlockAst;\nvar CssStyleSheetAst = (function (_super) {\n    __extends(CssStyleSheetAst, _super);\n    function CssStyleSheetAst(location, rules) {\n        var _this = _super.call(this, location) || this;\n        _this.rules = rules;\n        return _this;\n    }\n    CssStyleSheetAst.prototype.visit = function (visitor, context) {\n        return visitor.visitCssStyleSheet(this, context);\n    };\n    return CssStyleSheetAst;\n}(CssAst));\nexports.CssStyleSheetAst = CssStyleSheetAst;\nvar CssUnknownRuleAst = (function (_super) {\n    __extends(CssUnknownRuleAst, _super);\n    function CssUnknownRuleAst(location, ruleName, tokens) {\n        var _this = _super.call(this, location) || this;\n        _this.ruleName = ruleName;\n        _this.tokens = tokens;\n        return _this;\n    }\n    CssUnknownRuleAst.prototype.visit = function (visitor, context) {\n        return visitor.visitCssUnknownRule(this, context);\n    };\n    return CssUnknownRuleAst;\n}(CssRuleAst));\nexports.CssUnknownRuleAst = CssUnknownRuleAst;\nvar CssUnknownTokenListAst = (function (_super) {\n    __extends(CssUnknownTokenListAst, _super);\n    function CssUnknownTokenListAst(location, name, tokens) {\n        var _this = _super.call(this, location) || this;\n        _this.name = name;\n        _this.tokens = tokens;\n        return _this;\n    }\n    CssUnknownTokenListAst.prototype.visit = function (visitor, context) {\n        return visitor.visitCssUnknownTokenList(this, context);\n    };\n    return CssUnknownTokenListAst;\n}(CssRuleAst));\nexports.CssUnknownTokenListAst = CssUnknownTokenListAst;\nfunction mergeTokens(tokens, separator) {\n    if (separator === void 0) { separator = ''; }\n    var mainToken = tokens[0];\n    var str = mainToken.strValue;\n    for (var i = 1; i < tokens.length; i++) {\n        str += separator + tokens[i].strValue;\n    }\n    return new cssLexer_1.CssToken(mainToken.index, mainToken.column, mainToken.line, mainToken.type, str);\n}\nexports.mergeTokens = mergeTokens;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/angular/styles/cssLexer.js":"\"use strict\";\nvar chars = require(\"./chars\");\nvar CssTokenType;\n(function (CssTokenType) {\n    CssTokenType[CssTokenType[\"EOF\"] = 0] = \"EOF\";\n    CssTokenType[CssTokenType[\"String\"] = 1] = \"String\";\n    CssTokenType[CssTokenType[\"Comment\"] = 2] = \"Comment\";\n    CssTokenType[CssTokenType[\"Identifier\"] = 3] = \"Identifier\";\n    CssTokenType[CssTokenType[\"Number\"] = 4] = \"Number\";\n    CssTokenType[CssTokenType[\"IdentifierOrNumber\"] = 5] = \"IdentifierOrNumber\";\n    CssTokenType[CssTokenType[\"AtKeyword\"] = 6] = \"AtKeyword\";\n    CssTokenType[CssTokenType[\"Character\"] = 7] = \"Character\";\n    CssTokenType[CssTokenType[\"Whitespace\"] = 8] = \"Whitespace\";\n    CssTokenType[CssTokenType[\"Invalid\"] = 9] = \"Invalid\";\n})(CssTokenType = exports.CssTokenType || (exports.CssTokenType = {}));\nvar CssLexerMode;\n(function (CssLexerMode) {\n    CssLexerMode[CssLexerMode[\"ALL\"] = 0] = \"ALL\";\n    CssLexerMode[CssLexerMode[\"ALL_TRACK_WS\"] = 1] = \"ALL_TRACK_WS\";\n    CssLexerMode[CssLexerMode[\"SELECTOR\"] = 2] = \"SELECTOR\";\n    CssLexerMode[CssLexerMode[\"PSEUDO_SELECTOR\"] = 3] = \"PSEUDO_SELECTOR\";\n    CssLexerMode[CssLexerMode[\"PSEUDO_SELECTOR_WITH_ARGUMENTS\"] = 4] = \"PSEUDO_SELECTOR_WITH_ARGUMENTS\";\n    CssLexerMode[CssLexerMode[\"ATTRIBUTE_SELECTOR\"] = 5] = \"ATTRIBUTE_SELECTOR\";\n    CssLexerMode[CssLexerMode[\"AT_RULE_QUERY\"] = 6] = \"AT_RULE_QUERY\";\n    CssLexerMode[CssLexerMode[\"MEDIA_QUERY\"] = 7] = \"MEDIA_QUERY\";\n    CssLexerMode[CssLexerMode[\"BLOCK\"] = 8] = \"BLOCK\";\n    CssLexerMode[CssLexerMode[\"KEYFRAME_BLOCK\"] = 9] = \"KEYFRAME_BLOCK\";\n    CssLexerMode[CssLexerMode[\"STYLE_BLOCK\"] = 10] = \"STYLE_BLOCK\";\n    CssLexerMode[CssLexerMode[\"STYLE_VALUE\"] = 11] = \"STYLE_VALUE\";\n    CssLexerMode[CssLexerMode[\"STYLE_VALUE_FUNCTION\"] = 12] = \"STYLE_VALUE_FUNCTION\";\n    CssLexerMode[CssLexerMode[\"STYLE_CALC_FUNCTION\"] = 13] = \"STYLE_CALC_FUNCTION\";\n})(CssLexerMode = exports.CssLexerMode || (exports.CssLexerMode = {}));\nvar LexedCssResult = (function () {\n    function LexedCssResult(error, token) {\n        this.error = error;\n        this.token = token;\n    }\n    return LexedCssResult;\n}());\nexports.LexedCssResult = LexedCssResult;\nfunction generateErrorMessage(input, message, errorValue, index, row, column) {\n    return message + \" at column \" + row + \":\" + column + \" in expression [\" +\n        findProblemCode(input, errorValue, index, column) + ']';\n}\nexports.generateErrorMessage = generateErrorMessage;\nfunction findProblemCode(input, errorValue, index, column) {\n    var endOfProblemLine = index;\n    var current = charCode(input, index);\n    while (current > 0 && !isNewline(current)) {\n        current = charCode(input, ++endOfProblemLine);\n    }\n    var choppedString = input.substring(0, endOfProblemLine);\n    var pointerPadding = '';\n    for (var i = 0; i < column; i++) {\n        pointerPadding += ' ';\n    }\n    var pointerString = '';\n    for (var i = 0; i < errorValue.length; i++) {\n        pointerString += '^';\n    }\n    return choppedString + '\\n' + pointerPadding + pointerString + '\\n';\n}\nexports.findProblemCode = findProblemCode;\nvar CssToken = (function () {\n    function CssToken(index, column, line, type, strValue) {\n        this.index = index;\n        this.column = column;\n        this.line = line;\n        this.type = type;\n        this.strValue = strValue;\n        this.numValue = charCode(strValue, 0);\n    }\n    return CssToken;\n}());\nexports.CssToken = CssToken;\nvar CssLexer = (function () {\n    function CssLexer() {\n    }\n    CssLexer.prototype.scan = function (text, trackComments) {\n        if (trackComments === void 0) { trackComments = false; }\n        return new CssScanner(text, trackComments);\n    };\n    return CssLexer;\n}());\nexports.CssLexer = CssLexer;\nvar CssScannerError = (function () {\n    function CssScannerError(token, message) {\n        this.token = token;\n        this.rawMessage = message;\n    }\n    CssScannerError.prototype.toString = function () { return this.message; };\n    return CssScannerError;\n}());\nexports.CssScannerError = CssScannerError;\nfunction _trackWhitespace(mode) {\n    switch (mode) {\n        case CssLexerMode.SELECTOR:\n        case CssLexerMode.PSEUDO_SELECTOR:\n        case CssLexerMode.ALL_TRACK_WS:\n        case CssLexerMode.STYLE_VALUE:\n            return true;\n        default:\n            return false;\n    }\n}\nvar CssScanner = (function () {\n    function CssScanner(input, _trackComments) {\n        if (_trackComments === void 0) { _trackComments = false; }\n        this.input = input;\n        this._trackComments = _trackComments;\n        this.length = 0;\n        this.index = -1;\n        this.column = -1;\n        this.line = 0;\n        this._currentMode = CssLexerMode.BLOCK;\n        this._currentError = null;\n        this.length = this.input.length;\n        this.peekPeek = this.peekAt(0);\n        this.advance();\n    }\n    CssScanner.prototype.getMode = function () { return this._currentMode; };\n    CssScanner.prototype.setMode = function (mode) {\n        if (this._currentMode != mode) {\n            if (_trackWhitespace(this._currentMode) && !_trackWhitespace(mode)) {\n                this.consumeWhitespace();\n            }\n            this._currentMode = mode;\n        }\n    };\n    CssScanner.prototype.advance = function () {\n        if (isNewline(this.peek)) {\n            this.column = 0;\n            this.line++;\n        }\n        else {\n            this.column++;\n        }\n        this.index++;\n        this.peek = this.peekPeek;\n        this.peekPeek = this.peekAt(this.index + 1);\n    };\n    CssScanner.prototype.peekAt = function (index) {\n        return index >= this.length ? chars.$EOF : this.input.charCodeAt(index);\n    };\n    CssScanner.prototype.consumeEmptyStatements = function () {\n        this.consumeWhitespace();\n        while (this.peek == chars.$SEMICOLON) {\n            this.advance();\n            this.consumeWhitespace();\n        }\n    };\n    CssScanner.prototype.consumeWhitespace = function () {\n        while (chars.isWhitespace(this.peek) || isNewline(this.peek)) {\n            this.advance();\n            if (!this._trackComments && isCommentStart(this.peek, this.peekPeek)) {\n                this.advance();\n                this.advance();\n                while (!isCommentEnd(this.peek, this.peekPeek)) {\n                    if (this.peek == chars.$EOF) {\n                        this.error('Unterminated comment');\n                    }\n                    this.advance();\n                }\n                this.advance();\n                this.advance();\n            }\n        }\n    };\n    CssScanner.prototype.consume = function (type, value) {\n        if (value === void 0) { value = null; }\n        var mode = this._currentMode;\n        this.setMode(_trackWhitespace(mode) ? CssLexerMode.ALL_TRACK_WS : CssLexerMode.ALL);\n        var previousIndex = this.index;\n        var previousLine = this.line;\n        var previousColumn = this.column;\n        var next;\n        var output = this.scan();\n        if (output) {\n            if (output.error) {\n                this.setMode(mode);\n                return output;\n            }\n            next = output.token;\n        }\n        if (!next) {\n            next = new CssToken(this.index, this.column, this.line, CssTokenType.EOF, 'end of file');\n        }\n        var isMatchingType = false;\n        if (type == CssTokenType.IdentifierOrNumber) {\n            isMatchingType = next.type == CssTokenType.Number || next.type == CssTokenType.Identifier;\n        }\n        else {\n            isMatchingType = next.type == type;\n        }\n        this.setMode(mode);\n        var error = null;\n        if (!isMatchingType || (value && value != next.strValue)) {\n            var errorMessage = CssTokenType[next.type] + ' does not match expected ' +\n                CssTokenType[type] + ' value';\n            if (value) {\n                errorMessage += ' (\"' + next.strValue + '\" should match \"' + value + '\")';\n            }\n            error = new CssScannerError(next, generateErrorMessage(this.input, errorMessage, next.strValue, previousIndex, previousLine, previousColumn));\n        }\n        return new LexedCssResult(error, next);\n    };\n    CssScanner.prototype.scan = function () {\n        var trackWS = _trackWhitespace(this._currentMode);\n        if (this.index == 0 && !trackWS) {\n            this.consumeWhitespace();\n        }\n        var token = this._scan();\n        if (token == null)\n            return null;\n        var error = this._currentError;\n        this._currentError = null;\n        if (!trackWS) {\n            this.consumeWhitespace();\n        }\n        return new LexedCssResult(error, token);\n    };\n    CssScanner.prototype._scan = function () {\n        var peek = this.peek;\n        var peekPeek = this.peekPeek;\n        if (peek == chars.$EOF)\n            return null;\n        if (isCommentStart(peek, peekPeek)) {\n            var commentToken = this.scanComment();\n            if (this._trackComments) {\n                return commentToken;\n            }\n        }\n        if (_trackWhitespace(this._currentMode) && (chars.isWhitespace(peek) || isNewline(peek))) {\n            return this.scanWhitespace();\n        }\n        peek = this.peek;\n        peekPeek = this.peekPeek;\n        if (peek == chars.$EOF)\n            return null;\n        if (isStringStart(peek, peekPeek)) {\n            return this.scanString();\n        }\n        if (this._currentMode == CssLexerMode.STYLE_VALUE_FUNCTION) {\n            return this.scanCssValueFunction();\n        }\n        var isModifier = peek == chars.$PLUS || peek == chars.$MINUS;\n        var digitA = isModifier ? false : chars.isDigit(peek);\n        var digitB = chars.isDigit(peekPeek);\n        if (digitA || (isModifier && (peekPeek == chars.$PERIOD || digitB)) ||\n            (peek == chars.$PERIOD && digitB)) {\n            return this.scanNumber();\n        }\n        if (peek == chars.$AT) {\n            return this.scanAtExpression();\n        }\n        if (isIdentifierStart(peek, peekPeek)) {\n            return this.scanIdentifier();\n        }\n        if (isValidCssCharacter(peek, this._currentMode)) {\n            return this.scanCharacter();\n        }\n        return this.error(\"Unexpected character [\" + String.fromCharCode(peek) + \"]\");\n    };\n    CssScanner.prototype.scanComment = function () {\n        if (this.assertCondition(isCommentStart(this.peek, this.peekPeek), 'Expected comment start value')) {\n            return null;\n        }\n        var start = this.index;\n        var startingColumn = this.column;\n        var startingLine = this.line;\n        this.advance();\n        this.advance();\n        while (!isCommentEnd(this.peek, this.peekPeek)) {\n            if (this.peek == chars.$EOF) {\n                this.error('Unterminated comment');\n            }\n            this.advance();\n        }\n        this.advance();\n        this.advance();\n        var str = this.input.substring(start, this.index);\n        return new CssToken(start, startingColumn, startingLine, CssTokenType.Comment, str);\n    };\n    CssScanner.prototype.scanWhitespace = function () {\n        var start = this.index;\n        var startingColumn = this.column;\n        var startingLine = this.line;\n        while (chars.isWhitespace(this.peek) && this.peek != chars.$EOF) {\n            this.advance();\n        }\n        var str = this.input.substring(start, this.index);\n        return new CssToken(start, startingColumn, startingLine, CssTokenType.Whitespace, str);\n    };\n    CssScanner.prototype.scanString = function () {\n        if (this.assertCondition(isStringStart(this.peek, this.peekPeek), 'Unexpected non-string starting value')) {\n            return null;\n        }\n        var target = this.peek;\n        var start = this.index;\n        var startingColumn = this.column;\n        var startingLine = this.line;\n        var previous = target;\n        this.advance();\n        while (!isCharMatch(target, previous, this.peek)) {\n            if (this.peek == chars.$EOF || isNewline(this.peek)) {\n                this.error('Unterminated quote');\n            }\n            previous = this.peek;\n            this.advance();\n        }\n        if (this.assertCondition(this.peek == target, 'Unterminated quote')) {\n            return null;\n        }\n        this.advance();\n        var str = this.input.substring(start, this.index);\n        return new CssToken(start, startingColumn, startingLine, CssTokenType.String, str);\n    };\n    CssScanner.prototype.scanNumber = function () {\n        var start = this.index;\n        var startingColumn = this.column;\n        if (this.peek == chars.$PLUS || this.peek == chars.$MINUS) {\n            this.advance();\n        }\n        var periodUsed = false;\n        while (chars.isDigit(this.peek) || this.peek == chars.$PERIOD) {\n            if (this.peek == chars.$PERIOD) {\n                if (periodUsed) {\n                    this.error('Unexpected use of a second period value');\n                }\n                periodUsed = true;\n            }\n            this.advance();\n        }\n        var strValue = this.input.substring(start, this.index);\n        return new CssToken(start, startingColumn, this.line, CssTokenType.Number, strValue);\n    };\n    CssScanner.prototype.scanIdentifier = function () {\n        if (this.assertCondition(isIdentifierStart(this.peek, this.peekPeek), 'Expected identifier starting value')) {\n            return null;\n        }\n        var start = this.index;\n        var startingColumn = this.column;\n        while (isIdentifierPart(this.peek)) {\n            this.advance();\n        }\n        var strValue = this.input.substring(start, this.index);\n        return new CssToken(start, startingColumn, this.line, CssTokenType.Identifier, strValue);\n    };\n    CssScanner.prototype.scanCssValueFunction = function () {\n        var start = this.index;\n        var startingColumn = this.column;\n        var parenBalance = 1;\n        while (this.peek != chars.$EOF && parenBalance > 0) {\n            this.advance();\n            if (this.peek == chars.$LPAREN) {\n                parenBalance++;\n            }\n            else if (this.peek == chars.$RPAREN) {\n                parenBalance--;\n            }\n        }\n        var strValue = this.input.substring(start, this.index);\n        return new CssToken(start, startingColumn, this.line, CssTokenType.Identifier, strValue);\n    };\n    CssScanner.prototype.scanCharacter = function () {\n        var start = this.index;\n        var startingColumn = this.column;\n        if (this.assertCondition(isValidCssCharacter(this.peek, this._currentMode), charStr(this.peek) + ' is not a valid CSS character')) {\n            return null;\n        }\n        var c = this.input.substring(start, start + 1);\n        this.advance();\n        return new CssToken(start, startingColumn, this.line, CssTokenType.Character, c);\n    };\n    CssScanner.prototype.scanAtExpression = function () {\n        if (this.assertCondition(this.peek == chars.$AT, 'Expected @ value')) {\n            return null;\n        }\n        var start = this.index;\n        var startingColumn = this.column;\n        this.advance();\n        if (isIdentifierStart(this.peek, this.peekPeek)) {\n            var ident = this.scanIdentifier();\n            var strValue = '@' + ident.strValue;\n            return new CssToken(start, startingColumn, this.line, CssTokenType.AtKeyword, strValue);\n        }\n        else {\n            return this.scanCharacter();\n        }\n    };\n    CssScanner.prototype.assertCondition = function (status, errorMessage) {\n        if (!status) {\n            this.error(errorMessage);\n            return true;\n        }\n        return false;\n    };\n    CssScanner.prototype.error = function (message, errorTokenValue, doNotAdvance) {\n        if (errorTokenValue === void 0) { errorTokenValue = null; }\n        if (doNotAdvance === void 0) { doNotAdvance = false; }\n        var index = this.index;\n        var column = this.column;\n        var line = this.line;\n        errorTokenValue =\n            errorTokenValue ? errorTokenValue : String.fromCharCode(this.peek);\n        var invalidToken = new CssToken(index, column, line, CssTokenType.Invalid, errorTokenValue);\n        var errorMessage = generateErrorMessage(this.input, message, errorTokenValue, index, line, column);\n        if (!doNotAdvance) {\n            this.advance();\n        }\n        this._currentError = new CssScannerError(invalidToken, errorMessage);\n        return invalidToken;\n    };\n    return CssScanner;\n}());\nexports.CssScanner = CssScanner;\nfunction isCharMatch(target, previous, code) {\n    return code == target && previous != chars.$BACKSLASH;\n}\nfunction isCommentStart(code, next) {\n    return code == chars.$SLASH && next == chars.$STAR;\n}\nfunction isCommentEnd(code, next) {\n    return code == chars.$STAR && next == chars.$SLASH;\n}\nfunction isStringStart(code, next) {\n    var target = code;\n    if (target == chars.$BACKSLASH) {\n        target = next;\n    }\n    return target == chars.$DQ || target == chars.$SQ;\n}\nfunction isIdentifierStart(code, next) {\n    var target = code;\n    if (target == chars.$MINUS) {\n        target = next;\n    }\n    return chars.isAsciiLetter(target) || target == chars.$BACKSLASH || target == chars.$MINUS ||\n        target == chars.$_;\n}\nfunction isIdentifierPart(target) {\n    return chars.isAsciiLetter(target) || target == chars.$BACKSLASH || target == chars.$MINUS ||\n        target == chars.$_ || chars.isDigit(target);\n}\nfunction isValidPseudoSelectorCharacter(code) {\n    switch (code) {\n        case chars.$LPAREN:\n        case chars.$RPAREN:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction isValidKeyframeBlockCharacter(code) {\n    return code == chars.$PERCENT;\n}\nfunction isValidAttributeSelectorCharacter(code) {\n    switch (code) {\n        case chars.$$:\n        case chars.$PIPE:\n        case chars.$CARET:\n        case chars.$TILDA:\n        case chars.$STAR:\n        case chars.$EQ:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction isValidSelectorCharacter(code) {\n    switch (code) {\n        case chars.$HASH:\n        case chars.$PERIOD:\n        case chars.$TILDA:\n        case chars.$STAR:\n        case chars.$PLUS:\n        case chars.$GT:\n        case chars.$COLON:\n        case chars.$PIPE:\n        case chars.$COMMA:\n        case chars.$LBRACKET:\n        case chars.$RBRACKET:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction isValidStyleBlockCharacter(code) {\n    switch (code) {\n        case chars.$HASH:\n        case chars.$SEMICOLON:\n        case chars.$COLON:\n        case chars.$PERCENT:\n        case chars.$SLASH:\n        case chars.$BACKSLASH:\n        case chars.$BANG:\n        case chars.$PERIOD:\n        case chars.$LPAREN:\n        case chars.$RPAREN:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction isValidMediaQueryRuleCharacter(code) {\n    switch (code) {\n        case chars.$LPAREN:\n        case chars.$RPAREN:\n        case chars.$COLON:\n        case chars.$PERCENT:\n        case chars.$PERIOD:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction isValidAtRuleCharacter(code) {\n    switch (code) {\n        case chars.$LPAREN:\n        case chars.$RPAREN:\n        case chars.$COLON:\n        case chars.$PERCENT:\n        case chars.$PERIOD:\n        case chars.$SLASH:\n        case chars.$BACKSLASH:\n        case chars.$HASH:\n        case chars.$EQ:\n        case chars.$QUESTION:\n        case chars.$AMPERSAND:\n        case chars.$STAR:\n        case chars.$COMMA:\n        case chars.$MINUS:\n        case chars.$PLUS:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction isValidStyleFunctionCharacter(code) {\n    switch (code) {\n        case chars.$PERIOD:\n        case chars.$MINUS:\n        case chars.$PLUS:\n        case chars.$STAR:\n        case chars.$SLASH:\n        case chars.$LPAREN:\n        case chars.$RPAREN:\n        case chars.$COMMA:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction isValidBlockCharacter(code) {\n    return code == chars.$AT;\n}\nfunction isValidCssCharacter(code, mode) {\n    switch (mode) {\n        case CssLexerMode.ALL:\n        case CssLexerMode.ALL_TRACK_WS:\n            return true;\n        case CssLexerMode.SELECTOR:\n            return isValidSelectorCharacter(code);\n        case CssLexerMode.PSEUDO_SELECTOR_WITH_ARGUMENTS:\n            return isValidPseudoSelectorCharacter(code);\n        case CssLexerMode.ATTRIBUTE_SELECTOR:\n            return isValidAttributeSelectorCharacter(code);\n        case CssLexerMode.MEDIA_QUERY:\n            return isValidMediaQueryRuleCharacter(code);\n        case CssLexerMode.AT_RULE_QUERY:\n            return isValidAtRuleCharacter(code);\n        case CssLexerMode.KEYFRAME_BLOCK:\n            return isValidKeyframeBlockCharacter(code);\n        case CssLexerMode.STYLE_BLOCK:\n        case CssLexerMode.STYLE_VALUE:\n            return isValidStyleBlockCharacter(code);\n        case CssLexerMode.STYLE_CALC_FUNCTION:\n            return isValidStyleFunctionCharacter(code);\n        case CssLexerMode.BLOCK:\n            return isValidBlockCharacter(code);\n        default:\n            return false;\n    }\n}\nfunction charCode(input, index) {\n    return index >= input.length ? chars.$EOF : input.charCodeAt(index);\n}\nfunction charStr(code) {\n    return String.fromCharCode(code);\n}\nfunction isNewline(code) {\n    switch (code) {\n        case chars.$FF:\n        case chars.$CR:\n        case chars.$LF:\n        case chars.$VTAB:\n            return true;\n        default:\n            return false;\n    }\n}\nexports.isNewline = isNewline;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/angular/styles/cssParser.js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar chars = require(\"./chars\");\nvar parseUtil_1 = require(\"./parseUtil\");\nvar cssAst_1 = require(\"./cssAst\");\nvar cssLexer_1 = require(\"./cssLexer\");\nvar SPACE_OPERATOR = ' ';\nvar cssLexer_2 = require(\"./cssLexer\");\nexports.CssToken = cssLexer_2.CssToken;\nvar cssAst_2 = require(\"./cssAst\");\nexports.BlockType = cssAst_2.BlockType;\nvar SLASH_CHARACTER = '/';\nvar GT_CHARACTER = '>';\nvar TRIPLE_GT_OPERATOR_STR = '>>>';\nvar DEEP_OPERATOR_STR = '/deep/';\nvar EOF_DELIM_FLAG = 1;\nvar RBRACE_DELIM_FLAG = 2;\nvar LBRACE_DELIM_FLAG = 4;\nvar COMMA_DELIM_FLAG = 8;\nvar COLON_DELIM_FLAG = 16;\nvar SEMICOLON_DELIM_FLAG = 32;\nvar NEWLINE_DELIM_FLAG = 64;\nvar RPAREN_DELIM_FLAG = 128;\nvar LPAREN_DELIM_FLAG = 256;\nvar SPACE_DELIM_FLAG = 512;\nfunction _pseudoSelectorSupportsInnerSelectors(name) {\n    return ['not', 'host', 'host-context'].indexOf(name) >= 0;\n}\nfunction isSelectorOperatorCharacter(code) {\n    switch (code) {\n        case chars.$SLASH:\n        case chars.$TILDA:\n        case chars.$PLUS:\n        case chars.$GT:\n            return true;\n        default:\n            return chars.isWhitespace(code);\n    }\n}\nfunction getDelimFromCharacter(code) {\n    switch (code) {\n        case chars.$EOF:\n            return EOF_DELIM_FLAG;\n        case chars.$COMMA:\n            return COMMA_DELIM_FLAG;\n        case chars.$COLON:\n            return COLON_DELIM_FLAG;\n        case chars.$SEMICOLON:\n            return SEMICOLON_DELIM_FLAG;\n        case chars.$RBRACE:\n            return RBRACE_DELIM_FLAG;\n        case chars.$LBRACE:\n            return LBRACE_DELIM_FLAG;\n        case chars.$RPAREN:\n            return RPAREN_DELIM_FLAG;\n        case chars.$SPACE:\n        case chars.$TAB:\n            return SPACE_DELIM_FLAG;\n        default:\n            return cssLexer_1.isNewline(code) ? NEWLINE_DELIM_FLAG : 0;\n    }\n}\nfunction characterContainsDelimiter(code, delimiters) {\n    return (getDelimFromCharacter(code) & delimiters) > 0;\n}\nvar ParsedCssResult = (function () {\n    function ParsedCssResult(errors, ast) {\n        this.errors = errors;\n        this.ast = ast;\n    }\n    return ParsedCssResult;\n}());\nexports.ParsedCssResult = ParsedCssResult;\nvar CssParser = (function () {\n    function CssParser() {\n        this._errors = [];\n    }\n    CssParser.prototype.parse = function (css, url) {\n        var lexer = new cssLexer_1.CssLexer();\n        this._file = new parseUtil_1.ParseSourceFile(css, url);\n        this._scanner = lexer.scan(css, false);\n        var ast = this._parseStyleSheet(EOF_DELIM_FLAG);\n        var errors = this._errors;\n        this._errors = [];\n        var result = new ParsedCssResult(errors, ast);\n        this._file = null;\n        this._scanner = null;\n        return result;\n    };\n    CssParser.prototype._parseStyleSheet = function (delimiters) {\n        var results = [];\n        this._scanner.consumeEmptyStatements();\n        while (this._scanner.peek != chars.$EOF) {\n            this._scanner.setMode(cssLexer_1.CssLexerMode.BLOCK);\n            results.push(this._parseRule(delimiters));\n        }\n        var span = null;\n        if (results.length > 0) {\n            var firstRule = results[0];\n            span = this._generateSourceSpan(firstRule, this._lastToken);\n        }\n        return new cssAst_1.CssStyleSheetAst(span, results);\n    };\n    CssParser.prototype._getSourceContent = function () { return this._scanner ? this._scanner.input : ''; };\n    CssParser.prototype._extractSourceContent = function (start, end) {\n        return this._getSourceContent().substring(start, end + 1);\n    };\n    CssParser.prototype._generateSourceSpan = function (start, end) {\n        if (end === void 0) { end = null; }\n        var startLoc;\n        if (start instanceof cssAst_1.CssAst) {\n            startLoc = start.location.start;\n        }\n        else {\n            var token = start;\n            if (!token) {\n                token = this._lastToken;\n            }\n            startLoc = new parseUtil_1.ParseLocation(this._file, token.index, token.line, token.column);\n        }\n        if (!end) {\n            end = this._lastToken;\n        }\n        var endLine;\n        var endColumn;\n        var endIndex;\n        if (end instanceof cssAst_1.CssAst) {\n            endLine = end.location.end.line;\n            endColumn = end.location.end.col;\n            endIndex = end.location.end.offset;\n        }\n        else if (end instanceof cssLexer_1.CssToken) {\n            endLine = end.line;\n            endColumn = end.column;\n            endIndex = end.index;\n        }\n        var endLoc = new parseUtil_1.ParseLocation(this._file, endIndex, endLine, endColumn);\n        return new parseUtil_1.ParseSourceSpan(startLoc, endLoc);\n    };\n    CssParser.prototype._resolveBlockType = function (token) {\n        switch (token.strValue) {\n            case '@-o-keyframes':\n            case '@-moz-keyframes':\n            case '@-webkit-keyframes':\n            case '@keyframes':\n                return cssAst_1.BlockType.Keyframes;\n            case '@charset':\n                return cssAst_1.BlockType.Charset;\n            case '@import':\n                return cssAst_1.BlockType.Import;\n            case '@namespace':\n                return cssAst_1.BlockType.Namespace;\n            case '@page':\n                return cssAst_1.BlockType.Page;\n            case '@document':\n                return cssAst_1.BlockType.Document;\n            case '@media':\n                return cssAst_1.BlockType.MediaQuery;\n            case '@font-face':\n                return cssAst_1.BlockType.FontFace;\n            case '@viewport':\n                return cssAst_1.BlockType.Viewport;\n            case '@supports':\n                return cssAst_1.BlockType.Supports;\n            default:\n                return cssAst_1.BlockType.Unsupported;\n        }\n    };\n    CssParser.prototype._parseRule = function (delimiters) {\n        if (this._scanner.peek == chars.$AT) {\n            return this._parseAtRule(delimiters);\n        }\n        return this._parseSelectorRule(delimiters);\n    };\n    CssParser.prototype._parseAtRule = function (delimiters) {\n        var start = this._getScannerIndex();\n        this._scanner.setMode(cssLexer_1.CssLexerMode.BLOCK);\n        var token = this._scan();\n        var startToken = token;\n        this._assertCondition(token.type == cssLexer_1.CssTokenType.AtKeyword, \"The CSS Rule \" + token.strValue + \" is not a valid [@] rule.\", token);\n        var block;\n        var type = this._resolveBlockType(token);\n        var span;\n        var tokens;\n        var endToken;\n        var end;\n        var strValue;\n        var query;\n        switch (type) {\n            case cssAst_1.BlockType.Charset:\n            case cssAst_1.BlockType.Namespace:\n            case cssAst_1.BlockType.Import:\n                var value = this._parseValue(delimiters);\n                this._scanner.setMode(cssLexer_1.CssLexerMode.BLOCK);\n                this._scanner.consumeEmptyStatements();\n                span = this._generateSourceSpan(startToken, value);\n                return new cssAst_1.CssInlineRuleAst(span, type, value);\n            case cssAst_1.BlockType.Viewport:\n            case cssAst_1.BlockType.FontFace:\n                block = this._parseStyleBlock(delimiters);\n                span = this._generateSourceSpan(startToken, block);\n                return new cssAst_1.CssBlockRuleAst(span, type, block);\n            case cssAst_1.BlockType.Keyframes:\n                tokens = this._collectUntilDelim(delimiters | RBRACE_DELIM_FLAG | LBRACE_DELIM_FLAG);\n                var name_1 = tokens[0];\n                block = this._parseKeyframeBlock(delimiters);\n                span = this._generateSourceSpan(startToken, block);\n                return new cssAst_1.CssKeyframeRuleAst(span, name_1, block);\n            case cssAst_1.BlockType.MediaQuery:\n                this._scanner.setMode(cssLexer_1.CssLexerMode.MEDIA_QUERY);\n                tokens = this._collectUntilDelim(delimiters | RBRACE_DELIM_FLAG | LBRACE_DELIM_FLAG);\n                endToken = tokens[tokens.length - 1];\n                end = endToken.index + endToken.strValue.length - 1;\n                strValue = this._extractSourceContent(start, end);\n                span = this._generateSourceSpan(startToken, endToken);\n                query = new cssAst_1.CssAtRulePredicateAst(span, strValue, tokens);\n                block = this._parseBlock(delimiters);\n                strValue = this._extractSourceContent(start, this._getScannerIndex() - 1);\n                span = this._generateSourceSpan(startToken, block);\n                return new cssAst_1.CssMediaQueryRuleAst(span, strValue, query, block);\n            case cssAst_1.BlockType.Document:\n            case cssAst_1.BlockType.Supports:\n            case cssAst_1.BlockType.Page:\n                this._scanner.setMode(cssLexer_1.CssLexerMode.AT_RULE_QUERY);\n                tokens = this._collectUntilDelim(delimiters | RBRACE_DELIM_FLAG | LBRACE_DELIM_FLAG);\n                endToken = tokens[tokens.length - 1];\n                end = endToken.index + endToken.strValue.length - 1;\n                strValue = this._extractSourceContent(start, end);\n                span = this._generateSourceSpan(startToken, tokens[tokens.length - 1]);\n                query = new cssAst_1.CssAtRulePredicateAst(span, strValue, tokens);\n                block = this._parseBlock(delimiters);\n                strValue = this._extractSourceContent(start, block.end.offset);\n                span = this._generateSourceSpan(startToken, block);\n                return new cssAst_1.CssBlockDefinitionRuleAst(span, strValue, type, query, block);\n            default:\n                var listOfTokens_1 = [];\n                var tokenName = token.strValue;\n                this._scanner.setMode(cssLexer_1.CssLexerMode.ALL);\n                this._error(cssLexer_1.generateErrorMessage(this._getSourceContent(), \"The CSS \\\"at\\\" rule \\\"\" + tokenName + \"\\\" is not allowed to used here\", token.strValue, token.index, token.line, token.column), token);\n                this._collectUntilDelim(delimiters | LBRACE_DELIM_FLAG | SEMICOLON_DELIM_FLAG)\n                    .forEach(function (token) { listOfTokens_1.push(token); });\n                if (this._scanner.peek == chars.$LBRACE) {\n                    listOfTokens_1.push(this._consume(cssLexer_1.CssTokenType.Character, '{'));\n                    this._collectUntilDelim(delimiters | RBRACE_DELIM_FLAG | LBRACE_DELIM_FLAG)\n                        .forEach(function (token) { listOfTokens_1.push(token); });\n                    listOfTokens_1.push(this._consume(cssLexer_1.CssTokenType.Character, '}'));\n                }\n                endToken = listOfTokens_1[listOfTokens_1.length - 1];\n                span = this._generateSourceSpan(startToken, endToken);\n                return new cssAst_1.CssUnknownRuleAst(span, tokenName, listOfTokens_1);\n        }\n    };\n    CssParser.prototype._parseSelectorRule = function (delimiters) {\n        var start = this._getScannerIndex();\n        var selectors = this._parseSelectors(delimiters);\n        var block = this._parseStyleBlock(delimiters);\n        var ruleAst;\n        var span;\n        var startSelector = selectors[0];\n        if (block) {\n            var span = this._generateSourceSpan(startSelector, block);\n            ruleAst = new cssAst_1.CssSelectorRuleAst(span, selectors, block);\n        }\n        else {\n            var name = this._extractSourceContent(start, this._getScannerIndex() - 1);\n            var innerTokens = [];\n            selectors.forEach(function (selector) {\n                selector.selectorParts.forEach(function (part) {\n                    part.tokens.forEach(function (token) { innerTokens.push(token); });\n                });\n            });\n            var endToken = innerTokens[innerTokens.length - 1];\n            span = this._generateSourceSpan(startSelector, endToken);\n            ruleAst = new cssAst_1.CssUnknownTokenListAst(span, name, innerTokens);\n        }\n        this._scanner.setMode(cssLexer_1.CssLexerMode.BLOCK);\n        this._scanner.consumeEmptyStatements();\n        return ruleAst;\n    };\n    CssParser.prototype._parseSelectors = function (delimiters) {\n        delimiters |= LBRACE_DELIM_FLAG | SEMICOLON_DELIM_FLAG;\n        var selectors = [];\n        var isParsingSelectors = true;\n        while (isParsingSelectors) {\n            selectors.push(this._parseSelector(delimiters));\n            isParsingSelectors = !characterContainsDelimiter(this._scanner.peek, delimiters);\n            if (isParsingSelectors) {\n                this._consume(cssLexer_1.CssTokenType.Character, ',');\n                isParsingSelectors = !characterContainsDelimiter(this._scanner.peek, delimiters);\n                if (isParsingSelectors) {\n                    this._scanner.consumeWhitespace();\n                }\n            }\n        }\n        return selectors;\n    };\n    CssParser.prototype._scan = function () {\n        var output = this._scanner.scan();\n        var token = output.token;\n        var error = output.error;\n        if (error) {\n            this._error(error.rawMessage, token);\n        }\n        this._lastToken = token;\n        return token;\n    };\n    CssParser.prototype._getScannerIndex = function () { return this._scanner.index; };\n    CssParser.prototype._consume = function (type, value) {\n        if (value === void 0) { value = null; }\n        var output = this._scanner.consume(type, value);\n        var token = output.token;\n        var error = output.error;\n        if (error) {\n            this._error(error.rawMessage, token);\n        }\n        this._lastToken = token;\n        return token;\n    };\n    CssParser.prototype._parseKeyframeBlock = function (delimiters) {\n        delimiters |= RBRACE_DELIM_FLAG;\n        this._scanner.setMode(cssLexer_1.CssLexerMode.KEYFRAME_BLOCK);\n        var startToken = this._consume(cssLexer_1.CssTokenType.Character, '{');\n        var definitions = [];\n        while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n            definitions.push(this._parseKeyframeDefinition(delimiters));\n        }\n        var endToken = this._consume(cssLexer_1.CssTokenType.Character, '}');\n        var span = this._generateSourceSpan(startToken, endToken);\n        return new cssAst_1.CssBlockAst(span, definitions);\n    };\n    CssParser.prototype._parseKeyframeDefinition = function (delimiters) {\n        var start = this._getScannerIndex();\n        var stepTokens = [];\n        delimiters |= LBRACE_DELIM_FLAG;\n        while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n            stepTokens.push(this._parseKeyframeLabel(delimiters | COMMA_DELIM_FLAG));\n            if (this._scanner.peek != chars.$LBRACE) {\n                this._consume(cssLexer_1.CssTokenType.Character, ',');\n            }\n        }\n        var stylesBlock = this._parseStyleBlock(delimiters | RBRACE_DELIM_FLAG);\n        var span = this._generateSourceSpan(stepTokens[0], stylesBlock);\n        var ast = new cssAst_1.CssKeyframeDefinitionAst(span, stepTokens, stylesBlock);\n        this._scanner.setMode(cssLexer_1.CssLexerMode.BLOCK);\n        return ast;\n    };\n    CssParser.prototype._parseKeyframeLabel = function (delimiters) {\n        this._scanner.setMode(cssLexer_1.CssLexerMode.KEYFRAME_BLOCK);\n        return cssAst_1.mergeTokens(this._collectUntilDelim(delimiters));\n    };\n    CssParser.prototype._parsePseudoSelector = function (delimiters) {\n        var start = this._getScannerIndex();\n        delimiters &= ~COMMA_DELIM_FLAG;\n        var startingDelims = delimiters;\n        var startToken = this._consume(cssLexer_1.CssTokenType.Character, ':');\n        var tokens = [startToken];\n        if (this._scanner.peek == chars.$COLON) {\n            tokens.push(this._consume(cssLexer_1.CssTokenType.Character, ':'));\n        }\n        var innerSelectors = [];\n        this._scanner.setMode(cssLexer_1.CssLexerMode.PSEUDO_SELECTOR);\n        var pseudoSelectorToken = this._consume(cssLexer_1.CssTokenType.Identifier);\n        var pseudoSelectorName = pseudoSelectorToken.strValue;\n        tokens.push(pseudoSelectorToken);\n        if (this._scanner.peek == chars.$LPAREN) {\n            this._scanner.setMode(cssLexer_1.CssLexerMode.PSEUDO_SELECTOR_WITH_ARGUMENTS);\n            var openParenToken = this._consume(cssLexer_1.CssTokenType.Character, '(');\n            tokens.push(openParenToken);\n            if (_pseudoSelectorSupportsInnerSelectors(pseudoSelectorName)) {\n                var innerDelims = startingDelims | LPAREN_DELIM_FLAG | RPAREN_DELIM_FLAG;\n                if (pseudoSelectorName == 'not') {\n                    innerDelims |= COMMA_DELIM_FLAG;\n                }\n                this._parseSelectors(innerDelims).forEach(function (selector, index) {\n                    innerSelectors.push(selector);\n                });\n            }\n            else {\n                var innerValueDelims = delimiters | LBRACE_DELIM_FLAG | COLON_DELIM_FLAG |\n                    RPAREN_DELIM_FLAG | LPAREN_DELIM_FLAG;\n                while (!characterContainsDelimiter(this._scanner.peek, innerValueDelims)) {\n                    var token = this._scan();\n                    tokens.push(token);\n                }\n            }\n            var closeParenToken = this._consume(cssLexer_1.CssTokenType.Character, ')');\n            tokens.push(closeParenToken);\n        }\n        var end = this._getScannerIndex() - 1;\n        var strValue = this._extractSourceContent(start, end);\n        var endToken = tokens[tokens.length - 1];\n        var span = this._generateSourceSpan(startToken, endToken);\n        return new cssAst_1.CssPseudoSelectorAst(span, strValue, pseudoSelectorName, tokens, innerSelectors);\n    };\n    CssParser.prototype._parseSimpleSelector = function (delimiters) {\n        var start = this._getScannerIndex();\n        delimiters |= COMMA_DELIM_FLAG;\n        this._scanner.setMode(cssLexer_1.CssLexerMode.SELECTOR);\n        var selectorCssTokens = [];\n        var pseudoSelectors = [];\n        var previousToken;\n        var selectorPartDelimiters = delimiters | SPACE_DELIM_FLAG;\n        var loopOverSelector = !characterContainsDelimiter(this._scanner.peek, selectorPartDelimiters);\n        var hasAttributeError = false;\n        while (loopOverSelector) {\n            var peek = this._scanner.peek;\n            switch (peek) {\n                case chars.$COLON:\n                    var innerPseudo = this._parsePseudoSelector(delimiters);\n                    pseudoSelectors.push(innerPseudo);\n                    this._scanner.setMode(cssLexer_1.CssLexerMode.SELECTOR);\n                    break;\n                case chars.$LBRACKET:\n                    selectorCssTokens.push(this._scan());\n                    this._scanner.setMode(cssLexer_1.CssLexerMode.ATTRIBUTE_SELECTOR);\n                    break;\n                case chars.$RBRACKET:\n                    if (this._scanner.getMode() != cssLexer_1.CssLexerMode.ATTRIBUTE_SELECTOR) {\n                        hasAttributeError = true;\n                    }\n                    this._scanner.setMode(cssLexer_1.CssLexerMode.SELECTOR);\n                    selectorCssTokens.push(this._scan());\n                    break;\n                default:\n                    if (isSelectorOperatorCharacter(peek)) {\n                        loopOverSelector = false;\n                        continue;\n                    }\n                    var token = this._scan();\n                    previousToken = token;\n                    selectorCssTokens.push(token);\n                    break;\n            }\n            loopOverSelector = !characterContainsDelimiter(this._scanner.peek, selectorPartDelimiters);\n        }\n        hasAttributeError =\n            hasAttributeError || this._scanner.getMode() == cssLexer_1.CssLexerMode.ATTRIBUTE_SELECTOR;\n        if (hasAttributeError) {\n            this._error(\"Unbalanced CSS attribute selector at column \" + previousToken.line + \":\" + previousToken.column, previousToken);\n        }\n        var end = this._getScannerIndex() - 1;\n        if (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n            var operator = null;\n            var operatorScanCount = 0;\n            var lastOperatorToken = null;\n            while (operator == null && !characterContainsDelimiter(this._scanner.peek, delimiters) &&\n                isSelectorOperatorCharacter(this._scanner.peek)) {\n                var token = this._scan();\n                var tokenOperator = token.strValue;\n                operatorScanCount++;\n                lastOperatorToken = token;\n                if (tokenOperator != SPACE_OPERATOR) {\n                    switch (tokenOperator) {\n                        case SLASH_CHARACTER:\n                            var deepToken = this._consume(cssLexer_1.CssTokenType.Identifier);\n                            var deepSlash = this._consume(cssLexer_1.CssTokenType.Character);\n                            var index = lastOperatorToken.index;\n                            var line = lastOperatorToken.line;\n                            var column = lastOperatorToken.column;\n                            if (deepToken && deepToken.strValue.toLowerCase() == 'deep' &&\n                                deepSlash.strValue == SLASH_CHARACTER) {\n                                token = new cssLexer_1.CssToken(lastOperatorToken.index, lastOperatorToken.column, lastOperatorToken.line, cssLexer_1.CssTokenType.Identifier, DEEP_OPERATOR_STR);\n                            }\n                            else {\n                                var text = SLASH_CHARACTER + deepToken.strValue + deepSlash.strValue;\n                                this._error(cssLexer_1.generateErrorMessage(this._getSourceContent(), text + \" is an invalid CSS operator\", text, index, line, column), lastOperatorToken);\n                                token = new cssLexer_1.CssToken(index, column, line, cssLexer_1.CssTokenType.Invalid, text);\n                            }\n                            break;\n                        case GT_CHARACTER:\n                            if (this._scanner.peek == chars.$GT && this._scanner.peekPeek == chars.$GT) {\n                                this._consume(cssLexer_1.CssTokenType.Character, GT_CHARACTER);\n                                this._consume(cssLexer_1.CssTokenType.Character, GT_CHARACTER);\n                                token = new cssLexer_1.CssToken(lastOperatorToken.index, lastOperatorToken.column, lastOperatorToken.line, cssLexer_1.CssTokenType.Identifier, TRIPLE_GT_OPERATOR_STR);\n                            }\n                            break;\n                    }\n                    operator = token;\n                }\n            }\n            if (operator) {\n                end = operator.index;\n            }\n        }\n        this._scanner.consumeWhitespace();\n        var strValue = this._extractSourceContent(start, end);\n        if (operator == null && operatorScanCount > 0 && this._scanner.peek != chars.$LBRACE) {\n            operator = lastOperatorToken;\n        }\n        var startTokenOrAst = null;\n        var endTokenOrAst = null;\n        if (selectorCssTokens.length > 0) {\n            startTokenOrAst = startTokenOrAst || selectorCssTokens[0];\n            endTokenOrAst = selectorCssTokens[selectorCssTokens.length - 1];\n        }\n        if (pseudoSelectors.length > 0) {\n            startTokenOrAst = startTokenOrAst || pseudoSelectors[0];\n            endTokenOrAst = pseudoSelectors[pseudoSelectors.length - 1];\n        }\n        if (operator) {\n            startTokenOrAst = startTokenOrAst || operator;\n            endTokenOrAst = operator;\n        }\n        var span = this._generateSourceSpan(startTokenOrAst, endTokenOrAst);\n        return new cssAst_1.CssSimpleSelectorAst(span, selectorCssTokens, strValue, pseudoSelectors, operator);\n    };\n    CssParser.prototype._parseSelector = function (delimiters) {\n        delimiters |= COMMA_DELIM_FLAG;\n        this._scanner.setMode(cssLexer_1.CssLexerMode.SELECTOR);\n        var simpleSelectors = [];\n        while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n            simpleSelectors.push(this._parseSimpleSelector(delimiters));\n            this._scanner.consumeWhitespace();\n        }\n        var firstSelector = simpleSelectors[0];\n        var lastSelector = simpleSelectors[simpleSelectors.length - 1];\n        var span = this._generateSourceSpan(firstSelector, lastSelector);\n        return new cssAst_1.CssSelectorAst(span, simpleSelectors);\n    };\n    CssParser.prototype._parseValue = function (delimiters) {\n        delimiters |= RBRACE_DELIM_FLAG | SEMICOLON_DELIM_FLAG | NEWLINE_DELIM_FLAG;\n        this._scanner.setMode(cssLexer_1.CssLexerMode.STYLE_VALUE);\n        var start = this._getScannerIndex();\n        var tokens = [];\n        var wsStr = '';\n        var previous;\n        while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n            var token;\n            if (previous && previous.type == cssLexer_1.CssTokenType.Identifier &&\n                this._scanner.peek == chars.$LPAREN) {\n                token = this._consume(cssLexer_1.CssTokenType.Character, '(');\n                tokens.push(token);\n                this._scanner.setMode(cssLexer_1.CssLexerMode.STYLE_VALUE_FUNCTION);\n                token = this._scan();\n                tokens.push(token);\n                this._scanner.setMode(cssLexer_1.CssLexerMode.STYLE_VALUE);\n                token = this._consume(cssLexer_1.CssTokenType.Character, ')');\n                tokens.push(token);\n            }\n            else {\n                token = this._scan();\n                if (token.type == cssLexer_1.CssTokenType.Whitespace) {\n                    wsStr += token.strValue;\n                }\n                else {\n                    wsStr = '';\n                    tokens.push(token);\n                }\n            }\n            previous = token;\n        }\n        var end = this._getScannerIndex() - 1;\n        this._scanner.consumeWhitespace();\n        var code = this._scanner.peek;\n        if (code == chars.$SEMICOLON) {\n            this._consume(cssLexer_1.CssTokenType.Character, ';');\n        }\n        else if (code != chars.$RBRACE) {\n            this._error(cssLexer_1.generateErrorMessage(this._getSourceContent(), \"The CSS key/value definition did not end with a semicolon\", previous.strValue, previous.index, previous.line, previous.column), previous);\n        }\n        var strValue = this._extractSourceContent(start, end);\n        var startToken = tokens[0];\n        var endToken = tokens[tokens.length - 1];\n        var span = this._generateSourceSpan(startToken, endToken);\n        return new cssAst_1.CssStyleValueAst(span, tokens, strValue);\n    };\n    CssParser.prototype._collectUntilDelim = function (delimiters, assertType) {\n        if (assertType === void 0) { assertType = null; }\n        var tokens = [];\n        while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n            var val = assertType ? this._consume(assertType) : this._scan();\n            tokens.push(val);\n        }\n        return tokens;\n    };\n    CssParser.prototype._parseBlock = function (delimiters) {\n        delimiters |= RBRACE_DELIM_FLAG;\n        this._scanner.setMode(cssLexer_1.CssLexerMode.BLOCK);\n        var startToken = this._consume(cssLexer_1.CssTokenType.Character, '{');\n        this._scanner.consumeEmptyStatements();\n        var results = [];\n        while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n            results.push(this._parseRule(delimiters));\n        }\n        var endToken = this._consume(cssLexer_1.CssTokenType.Character, '}');\n        this._scanner.setMode(cssLexer_1.CssLexerMode.BLOCK);\n        this._scanner.consumeEmptyStatements();\n        var span = this._generateSourceSpan(startToken, endToken);\n        return new cssAst_1.CssBlockAst(span, results);\n    };\n    CssParser.prototype._parseStyleBlock = function (delimiters) {\n        delimiters |= RBRACE_DELIM_FLAG | LBRACE_DELIM_FLAG;\n        this._scanner.setMode(cssLexer_1.CssLexerMode.STYLE_BLOCK);\n        var startToken = this._consume(cssLexer_1.CssTokenType.Character, '{');\n        if (startToken.numValue != chars.$LBRACE) {\n            return null;\n        }\n        var definitions = [];\n        this._scanner.consumeEmptyStatements();\n        while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n            definitions.push(this._parseDefinition(delimiters));\n            this._scanner.consumeEmptyStatements();\n        }\n        var endToken = this._consume(cssLexer_1.CssTokenType.Character, '}');\n        this._scanner.setMode(cssLexer_1.CssLexerMode.STYLE_BLOCK);\n        this._scanner.consumeEmptyStatements();\n        var span = this._generateSourceSpan(startToken, endToken);\n        return new cssAst_1.CssStylesBlockAst(span, definitions);\n    };\n    CssParser.prototype._parseDefinition = function (delimiters) {\n        this._scanner.setMode(cssLexer_1.CssLexerMode.STYLE_BLOCK);\n        var prop = this._consume(cssLexer_1.CssTokenType.Identifier);\n        var parseValue = false;\n        var value = null;\n        var endToken = prop;\n        switch (this._scanner.peek) {\n            case chars.$SEMICOLON:\n            case chars.$RBRACE:\n            case chars.$EOF:\n                parseValue = false;\n                break;\n            default:\n                var propStr = [prop.strValue];\n                if (this._scanner.peek != chars.$COLON) {\n                    var nextValue = this._consume(cssLexer_1.CssTokenType.Character, ':');\n                    propStr.push(nextValue.strValue);\n                    var remainingTokens = this._collectUntilDelim(delimiters | COLON_DELIM_FLAG | SEMICOLON_DELIM_FLAG, cssLexer_1.CssTokenType.Identifier);\n                    if (remainingTokens.length > 0) {\n                        remainingTokens.forEach(function (token) { propStr.push(token.strValue); });\n                    }\n                    endToken = prop =\n                        new cssLexer_1.CssToken(prop.index, prop.column, prop.line, prop.type, propStr.join(' '));\n                }\n                if (this._scanner.peek == chars.$COLON) {\n                    this._consume(cssLexer_1.CssTokenType.Character, ':');\n                    parseValue = true;\n                }\n                break;\n        }\n        if (parseValue) {\n            value = this._parseValue(delimiters);\n            endToken = value;\n        }\n        else {\n            this._error(cssLexer_1.generateErrorMessage(this._getSourceContent(), \"The CSS property was not paired with a style value\", prop.strValue, prop.index, prop.line, prop.column), prop);\n        }\n        var span = this._generateSourceSpan(prop, endToken);\n        return new cssAst_1.CssDefinitionAst(span, prop, value);\n    };\n    CssParser.prototype._assertCondition = function (status, errorMessage, problemToken) {\n        if (!status) {\n            this._error(errorMessage, problemToken);\n            return true;\n        }\n        return false;\n    };\n    CssParser.prototype._error = function (message, problemToken) {\n        var length = problemToken.strValue.length;\n        var error = CssParseError.create(this._file, 0, problemToken.line, problemToken.column, length, message);\n        this._errors.push(error);\n    };\n    return CssParser;\n}());\nexports.CssParser = CssParser;\nvar CssParseError = (function (_super) {\n    __extends(CssParseError, _super);\n    function CssParseError(span, message) {\n        return _super.call(this, span, message) || this;\n    }\n    CssParseError.create = function (file, offset, line, col, length, errMsg) {\n        var start = new parseUtil_1.ParseLocation(file, offset, line, col);\n        var end = new parseUtil_1.ParseLocation(file, offset, line, col + length);\n        var span = new parseUtil_1.ParseSourceSpan(start, end);\n        return new CssParseError(span, 'CSS Parse Error: ' + errMsg);\n    };\n    return CssParseError;\n}(parseUtil_1.ParseError));\nexports.CssParseError = CssParseError;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/angular/styles/parseUtil.js":"\"use strict\";\nvar ParseLocation = (function () {\n    function ParseLocation(file, offset, line, col) {\n        this.file = file;\n        this.offset = offset;\n        this.line = line;\n        this.col = col;\n    }\n    ParseLocation.prototype.toString = function () {\n        return this.offset ? this.file.url + \"@\" + this.line + \":\" + this.col : this.file.url;\n    };\n    return ParseLocation;\n}());\nexports.ParseLocation = ParseLocation;\nvar ParseSourceFile = (function () {\n    function ParseSourceFile(content, url) {\n        this.content = content;\n        this.url = url;\n    }\n    return ParseSourceFile;\n}());\nexports.ParseSourceFile = ParseSourceFile;\nvar ParseSourceSpan = (function () {\n    function ParseSourceSpan(start, end, details) {\n        if (details === void 0) { details = null; }\n        this.start = start;\n        this.end = end;\n        this.details = details;\n    }\n    ParseSourceSpan.prototype.toString = function () {\n        return this.start.file.content.substring(this.start.offset, this.end.offset);\n    };\n    return ParseSourceSpan;\n}());\nexports.ParseSourceSpan = ParseSourceSpan;\nvar ParseErrorLevel;\n(function (ParseErrorLevel) {\n    ParseErrorLevel[ParseErrorLevel[\"WARNING\"] = 0] = \"WARNING\";\n    ParseErrorLevel[ParseErrorLevel[\"FATAL\"] = 1] = \"FATAL\";\n})(ParseErrorLevel = exports.ParseErrorLevel || (exports.ParseErrorLevel = {}));\nvar ParseError = (function () {\n    function ParseError(span, msg, level) {\n        if (level === void 0) { level = ParseErrorLevel.FATAL; }\n        this.span = span;\n        this.msg = msg;\n        this.level = level;\n    }\n    ParseError.prototype.toString = function () {\n        var source = this.span.start.file.content;\n        var ctxStart = this.span.start.offset;\n        var contextStr = '';\n        var details = '';\n        if (ctxStart) {\n            if (ctxStart > source.length - 1) {\n                ctxStart = source.length - 1;\n            }\n            var ctxEnd = ctxStart;\n            var ctxLen = 0;\n            var ctxLines = 0;\n            while (ctxLen < 100 && ctxStart > 0) {\n                ctxStart--;\n                ctxLen++;\n                if (source[ctxStart] === '\\n') {\n                    if (++ctxLines === 3) {\n                        break;\n                    }\n                }\n            }\n            ctxLen = 0;\n            ctxLines = 0;\n            while (ctxLen < 100 && ctxEnd < source.length - 1) {\n                ctxEnd++;\n                ctxLen++;\n                if (source[ctxEnd] === '\\n') {\n                    if (++ctxLines === 3) {\n                        break;\n                    }\n                }\n            }\n            var context_1 = source.substring(ctxStart, this.span.start.offset) + '[ERROR ->]' +\n                source.substring(this.span.start.offset, ctxEnd + 1);\n            contextStr = \" (\\\"\" + context_1 + \"\\\")\";\n        }\n        if (this.span.details) {\n            details = \", \" + this.span.details;\n        }\n        return \"\" + this.msg + contextStr + \": \" + this.span.start + details;\n    };\n    return ParseError;\n}());\nexports.ParseError = ParseError;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/angular/styles/parseCss.js":"\"use strict\";\nvar cssParser_1 = require(\"./cssParser\");\nexports.parseCss = function (text) {\n    var parser = new cssParser_1.CssParser();\n    return parser.parse(text, '').ast;\n};\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/angular/templates/referenceCollectorVisitor.js":"\"use strict\";\nvar ReferenceCollectorVisitor = (function () {\n    function ReferenceCollectorVisitor() {\n        this._variables = [];\n    }\n    ReferenceCollectorVisitor.prototype.visit = function (node, context) {\n        node.visit(this, context);\n        return this._variables;\n    };\n    ReferenceCollectorVisitor.prototype.visitBoundText = function (text, context) { };\n    ReferenceCollectorVisitor.prototype.visitElementProperty = function (prop, context) { };\n    ReferenceCollectorVisitor.prototype.visitReference = function (ast, context) { };\n    ReferenceCollectorVisitor.prototype.visitNgContent = function (ast, context) { };\n    ReferenceCollectorVisitor.prototype.visitVariable = function (ast, context) { };\n    ReferenceCollectorVisitor.prototype.visitAttr = function (ast, context) { };\n    ReferenceCollectorVisitor.prototype.visitText = function (text, context) { };\n    ReferenceCollectorVisitor.prototype.visitDirective = function (ast, context) { };\n    ReferenceCollectorVisitor.prototype.visitDirectiveProperty = function (ast, context) { };\n    ReferenceCollectorVisitor.prototype.visitEvent = function (ast, context) { };\n    ReferenceCollectorVisitor.prototype.visitEmbeddedTemplate = function (ast, context) {\n        var _this = this;\n        var references = ast.references.map(function (r) { return r.name; });\n        ast.children.forEach(function (e) { return _this.visit(e, context); });\n        this._variables = this._variables.concat(references);\n    };\n    ReferenceCollectorVisitor.prototype.visitElement = function (element, context) {\n        var _this = this;\n        var references = element.references.map(function (r) { return r.name; });\n        element.children.forEach(function (e) { return _this.visit(e, context); });\n        this._variables = this._variables.concat(references);\n    };\n    Object.defineProperty(ReferenceCollectorVisitor.prototype, \"variables\", {\n        get: function () {\n            return this._variables;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return ReferenceCollectorVisitor;\n}());\nexports.ReferenceCollectorVisitor = ReferenceCollectorVisitor;\n","/home/travis/build/npmtest/node-npmtest-codelyzer/node_modules/codelyzer/angular/templates/templateParser.js":"\"use strict\";\nvar core_1 = require(\"@angular/core\");\nvar compiler = require(\"@angular/compiler\");\nvar config_1 = require(\"../config\");\nvar ngVersion_1 = require(\"../../util/ngVersion\");\nvar refId = 0;\nvar dummyMetadataFactory = function (declaration) {\n    if (refId > 1e10) {\n        refId = 0;\n    }\n    return {\n        inputs: declaration.inputs || [],\n        outputs: declaration.outputs || [],\n        hostListeners: declaration.hostListeners || {},\n        hostProperties: declaration.hostProperties || {},\n        hostAttributes: declaration.hostAttributes || {},\n        isSummary: true,\n        type: {\n            diDeps: [],\n            lifecycleHooks: [],\n            isHost: false,\n            reference: ++refId + '-ref'\n        },\n        isComponent: false,\n        selector: declaration.selector,\n        exportAs: declaration.exportAs,\n        providers: [],\n        viewProviders: [],\n        queries: [],\n        entryComponents: [],\n        changeDetection: 0,\n        template: {\n            isSummary: true,\n            animations: [],\n            ngContentSelectors: [],\n            encapsulation: 0\n        }\n    };\n};\nvar Console = (function () {\n    function Console() {\n    }\n    Console.prototype.log = function (message) { };\n    Console.prototype.warn = function (message) { };\n    return Console;\n}());\nvar defaultDirectives = [];\nexports.parseTemplate = function (template, directives) {\n    if (directives === void 0) { directives = []; }\n    defaultDirectives = directives.map(function (d) { return dummyMetadataFactory(d); });\n    var TemplateParser = compiler.TemplateParser;\n    var expressionParser = new compiler.Parser(new compiler.Lexer());\n    var elementSchemaRegistry = new compiler.DomElementSchemaRegistry();\n    var ngConsole = new Console();\n    var htmlParser = new compiler.I18NHtmlParser(new compiler.HtmlParser());\n    var tmplParser;\n    ngVersion_1.SemVerDSL\n        .gte('4.0.0-beta.8', function () {\n        var config = new compiler.CompilerConfig({});\n        tmplParser =\n            new TemplateParser(config, expressionParser, elementSchemaRegistry, htmlParser, ngConsole, []);\n    })\n        .else(function () {\n        tmplParser =\n            new TemplateParser(expressionParser, elementSchemaRegistry, htmlParser, ngConsole, []);\n    });\n    var interpolation = config_1.Config.interpolation;\n    var summaryKind = (compiler.CompileSummaryKind || {}).Template;\n    var templateMetadata = {\n        encapsulation: 0,\n        template: template,\n        templateUrl: '',\n        styles: [],\n        isInline: true,\n        styleUrls: [],\n        ngContentSelectors: [],\n        animations: [],\n        externalStylesheets: [],\n        interpolation: interpolation,\n        toSummary: function () {\n            return {\n                isSummary: true,\n                animations: this.animations.map(function (anim) { return anim.name; }),\n                ngContentSelectors: this.ngContentSelectors,\n                encapsulation: this.encapsulation,\n                summaryKind: summaryKind\n            };\n        }\n    };\n    var type = {\n        diDeps: [],\n        lifecycleHooks: [],\n        reference: null,\n        isHost: false,\n        name: '',\n        prefix: '',\n        moduleUrl: '',\n        value: '',\n        identifier: null\n    };\n    var result = tmplParser.tryParse(compiler.CompileDirectiveMetadata.create({ type: type, template: templateMetadata }), template, defaultDirectives, [], [core_1.NO_ERRORS_SCHEMA], '').templateAst;\n    return result;\n};\n"}